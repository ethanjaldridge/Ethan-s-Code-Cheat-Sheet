<!DOCTYPE html>

<html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="styles.css">
        <title>JavaScript</title>
    </head>
    
    <body>

        <!--Header-->

        <header>
            <h1>JavaScript</h1>
            <nav>
                <ul>
                    <li class ="headernav"><a href="index.html">Home</a></li>
                    <li class ="headernav"><a href="terminology.html">Terminology</a></li>
                    <li class ="headernav"><a href="keyboardcommands.html">Keyboard Commands</a></li>
                    <li class ="headernav"><a href="emmet.html">Emmet</a></li>
                    <li class ="headernav"><a href="git.html">Git & GitHub</a></li>
                    <li class ="headernav"><a href="markdown.html">Markdown</a></li>
                    <li class ="headernav"><a href="bash.html">Bash</a></li>
                    <li class ="headernav"><a href="html.html">HTML</a></li>
                    <li class ="headernav"><a href="css.html">CSS</a></li>
                    <li class ="headernav"><a href="#">JavaScript</a></li>
                    <li class ="headernav"><a href="Node.js.html">Node.js</a></li>
                </ul>
            </nav>
        </header>

        <!-- How to Run JavaScript -->
        <table>
            <thead>
                <tr>
                    <td colspan="3">How to Run JavaScript</td> 
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th scope="col" class="example">Example</th>
                    <th scope="col" class="name">Name</th>
                    <th scope="col" class="description">Description</th>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Runtime Environment(s)</td>
                    <td>A <em>runtime environment</em> is where your program will be executed. It determines what global objects your program can access and it can also impact how it runs. There are 2 primary runtime environments: the runtime environment of a browser, and the runtime environment of a Node. Certain aspects of JavaScript, such as methods, can be built into the runtime environment chosen. For example, any program executed in a browser has access to the browser's runtime environment. In fact, the <em>window</em> object provides access to a huge amount of data and functionality relating to the open browser window. Applications created for and executed in the browser are known as front-end applications.
                        <br>
                        <br>In 2009, the Node runtime environment was created for the purpose of executing JavaScript code without a browser, thus enabling programmers to create full-stack (front-end and back-end) applications using only the JavaScript language. Node is an entirely different runtime environment, meaning that browser-environment data values and functions, like window.alert(), can’t be used. Instead, the Node runtime environment gives back-end applications access to a variety of features unavailable in a browser, such as access to the server’s file system, database, and network. This is where console.log() would be used instead of window.alert(). Some sample Node.js code: 
                        <br><em>// my-app.js console.log(process.env.PWD);</em>. 
                        <br>
                        <br>In this example, <em>process</em> is an object containing data relating to the JavaScript file being executed. <em>process.env</em> is an object containing environment variables such as <em>process.env.PWD</em> which contains the current working directory (and stands for “Print Working Directory”). To execute the JavaScript code in this file, first make sure that you have set up Node on your computer. Then, open up a terminal and run the following command: 
                        <br><em>$ node my-app.js 
                        <br>/path/to/working/directory</em>
                        <br>
                        <br>The node command tells your computer to execute the my-app.js file in the Node environment. You can also use the node command without a file argument to open up the Node Read-Eval-Print-Loop (REPL):
                        <br><em>$ node
                        <br>> process.env.HOME
                        <br>'/home/ccuser'</em>
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Browser Console</td>
                    <td>JS code is normally added using the HTML &lt;script&gt; element for executing in web browsers, but most modern browsers also provide a console as part of their developer tools where we can directly write and run JS, typically for testing and debugging purposes. The console is essentially a REPL (Read-Evaluate-Print-Loop) that allows us to execute JS within the context of the page, such as modifying the page’s DOM (Document Object Model) or logging to the console. The console itself is also the place to view the messages that were logged by JS code, as well as any other information that the browser had documented, including network requests and security errors.
                        <br>
                        <br><strong>How to Open JS in DevTools (changes are temporary):</strong>
                        <br>
                        <br><ul>
                                <li>Bring up the developer tools by right clicking on a webpage and selecting <em>Inspect</em> or <em>Inspect Element</em>, and then navigate to the <em>Console</em> tab from there.</li>
                                <li>When you pull up the console, you might see some messages that have been logged by the browser, depending on what site you’re on. If you do, feel free to run clear() first to clear the console.</li>
                                <li>A list of the built-in functions and objects that are available to use in the console can be found in the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects">MDN web docs</a>. Notice that two new lines appear after running the previous code, one preceded by the < arrow and one without. This is because console.log() simply prints the message to the console and does not return anything. Thus, the first line we see is the logged message, and the second line that starts with < is the return value, or undefined.</li>
                                <li>What makes the console particularly useful is that we could also directly inspect and modify the page’s DOM if we wanted to. To bring up a blank page, we can enter about:blank into the browser’s address bar. We can confirm that there is no HTML inside the &lt;body&gt; element of the page by checking document.body.innerHTML in the console.</li>
                                <li>The console also recognizes $() as an alias for document.querySelector() to select an element. This shorthand resembles jQuery syntax and helps make manipulating the DOM through the console even more efficient.</li>
                            </ul>
                    </td>
                </tr>
                <tr>
                    <td class="vocab">&lt;script&gt;&lt;/script&gt;</td>
                    <td>Embedding JavaScript in HTML</td>
                    <td>&lt;script&gt; allows you to embed JavaScript code into an HTML file (within the &lt;head&gt; of your HTML file).
                        <br>
                        <br>Browsers come equipped with <em>HTML parsers</em> that help browsers render the elements accordingly. The HTML parser does NOT process the next element in the HTML file until it loads and executes the &lt;script&gt; element, thus leading to a delay in load time and resulting in a poor user experience. Additionally, scripts are loaded sequentially, so if one script depends on another script, they should be placed in that very order inside the HTML file. Use either <em>async</em> or <em>defer</em> just before the &gt; of your opening script tag.
                        <br>
                        <br>The <strong>async</strong> attribute loads and executes the script asynchronously with the rest of the webpage. async is useful for scripts that are independent of other scripts in order to function accordingly. 
                        <br>
                        <br>The <strong>defer</strong> attribute specifies that scripts should be executed after the HTML file is completely parsed. Scripts with the defer attribute are executed in order (i.e. first script 1, then script 2). When a script contains functionality that requires interaction with the DOM, the defer attribute is the way to go.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">&lt;script src="./script.js"&gt;&lt;/script&gt;</td>
                    <td>Linking JavaScript to HTML</td>
                    <td>The src="" attribute allows you to link a JavaScript file to an HTML file (again in the &lt;head&gt; of your HTML).
                        <br>
                        <br>Linking code is preferable because of a programming concept called Separation of Concerns (SoC). Instead of having messy code that is all in the same file, web developers separate their code into different files, making each “concern” easier to understand and more convenient when changes must be made.
                    </td>
                </tr>
            </tbody>
        </table>

        <!-- The DOM -->
        <table>
            <thead>
                <tr>
                    <td colspan="3">The DOM</td> 
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th scope="col" class="example">Example</th>
                    <th scope="col" class="name">Name</th>
                    <th scope="col" class="description">Description</th>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>DOM</td>
                    <td>Document Object Model. A tree-like structure of the webpage (document -> html -> head / body -> etc.) where each element is referred to as a <em>node: an intersecting point in a tree that contains data</em>. The top-most node is called the <em>root node</em>, which represents the html document. The DOM is implemented by browsers to allow JavaScript to access, modify, and update the structure of an HTML web page in an organized way. For this reason, we like to think of the DOM as the link between an HTML web page and scripting languages.</td>
                </tr>
                <tr>
                    <td class="vocab">document.body</td>
                    <td>document</td>
                    <td>The <strong>document</strong> object in JavaScript is the door to the DOM structure. The document object allows you to access the root node of the DOM tree. Before you can access a specific element in the page, first you must access the document structure itself. The document object allows scripts to access children of the DOM as properties. <a href="https://developer.mozilla.org/en-US/docs/Web/API/Document">List of document properties</a>.</td>
                </tr>
                <tr>
                    <td class="vocab">document.body.innerHTML = '&lt;h1&gt;This is now the heading of the body element&lt;/h1&gt;';</td>
                    <td>Tweaking Elements</td>
                    <td>When using the DOM in your script to access an HTML element, whether it’s an &lt;li&gt; element or the entire &lt;body&gt; element, you also have access to all of that element’s properties. This includes the ability to modify the contents of the element as well as its attributes and properties, which can range from modifying the text inside a &lt;p&gt; element to assigning a new background color to a &lt;div&gt;. For example, the <strong>.innerHTML</strong> property allows you to access and set the contents of an element.</td>
                </tr>
                <tr>
                    <td class="vocab">document.querySelector('p');
                        <br>
                        <br>document.getElementById('bio').innerHTML = 'The description';
                        <br>
                        <br>document.getElementsByClassName('student')[0].innerHTML = 'Not yet registered';
                        <br>
                        <br>document.getElementsByTagName('li')[1].innerHTML = 'Cedric Diggory`;
                    </td>
                    <td>Select & Modify Elements</td>
                    <td>The DOM interface allows us to access a specific element with CSS selectors. Selectors can include a tag name, a class, or an ID.
                        <br>
                        <br>The <strong>.querySelector()</strong> method allows us to specify a CSS selector as a string and returns the first element that matches that selector.
                        <br>
                        <br>The <strong>.getElementById()</strong> method allows us to access an element directly by its id. In this example, we’ve selected the element with an ID of 'bio' and set its .innerHTML to the text 'The description'. Notice that the ID is passed as a string, wrapped in quotation marks (' ').
                        <br>
                        <br>There are also the <strong>.getElementsByClassName()</strong> and <strong>.getElementsByTagName()</strong> methods which return an array of elements, instead of just one element. You can use bracket notation to access individual elements of an array.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">let blueElement = document.querySelector('.blue');
                        <br>blueElement.style.backgroundColor = 'blue';
                        <br>
                        <br>document.querySelector('.blue').style.fontFamily = 'Roboto';
                    </td>
                    <td>Style an Element</td>
                    <td>The <strong>.style</strong> property of a DOM element provides access to the inline style of that HTML tag. The syntax follows an <strong>element.style.property</strong> format, with the property representing a CSS property. For example, the following code selects the first element with a class of blue and assigns blue as the background-color. <a href="https://www.w3schools.com/jsref/dom_obj_style.asp" target="_blank">How CSS properties are converted into JavaScript</a>.</td>
                </tr>
                <tr>
                    <td class="vocab">let parentElement = document.getElementById('must-have').parentNode;
                        <br>
                        <br>//Returns the parent element of the element with an ID of 'must-have'.
                    </td>
                    <td>Traversing the DOM</td>
                    <td>Each element has a <strong>.parentNode</strong> and <strong>.children</strong> property. The .parentNode property returns the parent of the specified element in the DOM hierarchy. Note that the document element is the root node so its .parentNode property will return <em>null</em>. The .children property returns an array of the specified element’s children. If the element does not have any children, it will return null.</td>
                </tr>
                <tr>
                    <td class="vocab">let paragraph = document.createElement('p');
                        <br>
                        <br>paragraph.id = 'info'; 
                        <br>paragraph.innerHTML = 'The text inside the paragraph';
                        <br>
                        <br>document.body.appendChild(paragraph);
                    </td>
                    <td>Create & Insert Elements</td>
                    <td>The <strong>.createElement()</strong> method creates a new element based on the specified tag name passed into it as an argument. However, it does not append it to the document. It creates an empty element with no inner HTML.
                        <br>
                        <br>We can assign values to the properties of the newly created element like how we’ve done previously with existing elements.
                        <br>
                        <br>In order to create an element and add it to the web page, you must assign it to be the child of an element that already exists on the DOM, referred to as the parent element. We call this process <em>appending</em>. The <strong>.appendChild()</strong> method will add a child element as the parent element’s last child node.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">let paragraph = document.querySelector('p');
                        <br>document.body.removeChild(paragraph);
                        <br>
                        <br>document.getElementById('sign').hidden = true;
                    </td>
                    <td>Remove an Element</td>
                    <td>The <strong>.removeChild()</strong> method removes a specified child from a parent.
                        <br>
                        <br>If you want to hide an element rather than completely deleting it, the <strong>.hidden</strong> property allows you to hide it by setting the property as <strong>true</strong> or <strong>false</strong>.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">let element = document.querySelector('button');
                        <br>
                        <br>function turnBlue() {
                        <br>&ensp;element.style.backgroundColor = 'blue'; 
                        <br>};
                        <br>
                        <br>element.onclick = turnBlue;
                    </td>
                    <td>Add Click Interactivity</td>
                    <td>You can add interactivity to DOM elements by assigning a function to run based on an event. Events can include anything from a click to a user mousing over an element.
                        <br>
                        <br>The <strong>.onclick</strong> property allows you to assign a function to run when a click event happens on an element.
                    </td>
                </tr>
            </tbody>
        </table>

        <!-- DOM Events -->
        <table>
            <thead>
                <tr>
                    <td colspan="3">DOM Events</td> 
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th scope="col" class="example">Example</th>
                    <th scope="col" class="name">Name</th>
                    <th scope="col" class="description">Description</th>
                </tr>
                <tr>
                    <td class ="vocab"></td>
                    <td>Events</td>
                    <td>Events on the web are user interactions and browser manipulations that you can program to trigger functionality. Some other examples of events are:
                        <br>
                        <br>
                            <ul>
                                <li>A mouse clicking on a button</li>
                                <li>Webpage files loading in the browser</li>
                                <li>A user swiping right on an image</li>
                            </ul>
                    </td>
                </tr>
                <tr>
                    <td class ="vocab">function eventHandlerFunction() {
                        <br>&ensp;// this block of code will run when click event happens
                        <br>}
                        <br>
                        <br>eventTarget.addEventListener('click', eventHandlerFunction);
                        <br>
                        <br>eventTarget.onclick = eventHandlerFunction;
                    </td>
                    <td>Event Handler Functions</td>
                    <td>After a specific event fires on a specific element in the document object model (or DOM), an <em>event handler</em> function can be created to run as a response.
                        <br>
                        <br>Using the <strong>.addEventListener()</strong> method, we can have a DOM element listen for a specific event and execute a block of code when the event is detected. The DOM element that listens for an event is called the <em>event target</em> and the block of code that runs when the event happens is called the <em>event handler</em>. With the <strong>.addEventListener()</strong> method , we can add multiple event handler functions.
                        <br>
                        <br>Event Handlers can also be registered by setting an <strong>.onevent</strong> property on a DOM element (<em>event target</em>). The pattern for registering a specific event is to <strong>append an element with .on followed by the lowercased event type name</strong>. With <strong>.onevent</strong>, it allows for one event handler function to be attached to the event target.
                    </td>
                </tr>
                <tr>
                    <td class ="vocab">eventTarget.removeEventListener('click', eventHandlerFunction);</td>
                    <td>Removing <br>Event Handler Functions</td>
                    <td>The <strong>.removeEventListener()</strong> method is used to reverse the <em>.addEventListener()</em> method. This method stops the event target from “listening” for an event to fire when it no longer needs to. If <em>.addEventListener()</em> was provided an anonymous function, then that event listener cannot be removed. <strong>.removeEventListener()</strong> also takes two arguments:
                        <br>
                        <br>
                            <ul>
                                <li>The event type as a string</li>
                                <li>The event handler function</li>
                            </ul>
                    </td>
                </tr>
                <tr>
                    <td class ="vocab">function eventHandlerFunction(event){
                        <br>&ensp;console.log(event.timeStamp);
                        <br>}
                        <br>
                        <br>eventTarget.addEventListener('click', eventHandlerFunction);
                        <br>
                        <br>let sharePhoto = function(event) {
                        <br>&ensp;event.target.style.display = 'none';
                        <br>};
                    </td>
                    <td>Event Object Properties</td>
                    <td>JavaScript stores events as Event objects with their related data and functionalities as properties and methods. When an event is triggered, the event object can be passed as an argument to the event handler function. There are pre-determined properties associated with event objects. You can call these properties to see information about the event, for example:
                        <br>
                        <br>
                            <ul>
                                <li>the <strong>.target</strong> property to reference the element that the event is registered to.</li>
                                <li>the <strong>.type</strong> property to access the name of the event.</li>
                                <li>the <strong>.timeStamp</strong> property to access the number of milliseconds that passed since the document loaded and the event was triggered.</li>
                            </ul>
                    </td>
                </tr>
                <tr>
                    <td class ="vocab"></td>
                    <td>Event Types</td>
                    <td>Most events in the DOM take place without being noticed because there are no event handlers connected to them. It’s also important to know some registered events don’t depend on user interactions to fire. For instance, the <em>load</em> event fires after website files completely load in the browser. <a href="https://developer.mozilla.org/en-US/docs/Web/Events" target="_blank">List of Events</a>.
                        <br>
                        <br>Many events need user interaction with the DOM to fire (see mouse events below).
                        <br>
                        <br>
                            <ul>
                                <li>The <strong>click</strong> event fires when the user presses and releases a mouse button on an element in the DOM.</li>
                                <li>The <strong>mousedown</strong> event is fired when the user presses a mouse button down. This is different from a <em>click</em> event because mousedown doesn’t need the mouse button to be released to fire.</li>
                                <li>The <strong>mouseup</strong> event is fired when the user releases the mouse button. This is different from the <em>click</em> and <em>mousedown</em> events because <em>mouseup</em> doesn’t depend on the mouse button being pressed down to fire.</li>
                                <li>The <strong>mouseover</strong> event is fired when the mouse enters the content of an element.</li>
                                <li>The <strong>mouseout</strong> event is fired when the mouse leaves an element.</li>
                                <li>The <strong>wheel</strong> event fires when the user rotates a wheel button on a pointing device (typically a mouse).</li>
                            </ul>
                    </td>
                </tr>
                <tr>
                    <td class ="vocab"></td>
                    <td>Keyboard Events</td>
                    <td><em>Keyboard events</em> are triggered by user interaction with keyboard keys in the browser. Keyboard events have unique properties assigned to their event objects like the <strong>.key</strong> property that stores the values of the key pressed by the user. You can program the event handler function to react to a specific key, or react to any interaction with the keyboard.
                        <br>
                        <br>
                            <ul>
                                <li>The <strong>keydown</strong> event is fired while a user presses a key down.</li>
                                <li>The <strong>keyup</strong> event is fired while a user releases a key.</li>
                                <li>The <strong>keypress</strong> event is fired when a user presses a key down and releases it.</li>
                            </ul>
                    </td>
                </tr>
            </tbody>
        </table>

        <!-- Asynchronous JS -->
        <table>
            <thead>
                <tr>
                    <td colspan="3">Asynchronous JS</td>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="vocab"></td>
                    <td>Synchronous Code</td>
                    <td>Executes in sequential order — it starts with the code at the top of the file and executes line by line until it gets to the end of the file. This type of behavior is known as <strong>blocking</strong> (or blocking code) since each line of code cannot execute until the previous line finishes.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Asynchronous Code</td>
                    <td>Can be executed in parallel to other code that is already running. Without the need to wait for other code to finish before executing, our apps can save time and be more efficient. This type of behavior is considered <strong>non-blocking</strong>.
                        <br>
                        <br>For most programming languages, the ability to execute asynchronous code depends on the number of <strong>threads</strong> that an app has access to. We can think of a thread as a resource that a computer provides an app to do a task. Typically one thread allows for an app to complete one task.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">Event Listeners
                        <br>
                        <br>setTimeout(() => {
                        <br>&emsp;console.log('Delay the printing of this string, please.');
                        <br>}, 1000);
                        <br>
                        <br>setInterval(() => {
                        <br>&emsp;alert('Are you paying attention???')
                        <br>}, 300000);
                    </td>
                    <td>JavaScript and Asynchronous Code</td>
                    <td>JavaScript is a <strong>single-threaded language</strong>. This means it has a single thread that can carry out one task at a time. However, Javascript has what is known as the <strong>event loop</strong>, a specific design that allows it to perform asynchronous tasks even while only using a single thread.
                        <br>
                        <br><ul>
                                <li><strong>Asynchronous Callbacks:</strong> a type of callback function that executes after a specific condition is met and runs concurrently to any other code currently running.</li>
                                <li><strong>setTimeout()</strong> tells our JavaScript program to wait a minimum amount of time before executing its callback function. Takes 2 arguments, a callback function and a number specifying how long to wait before executing the function (in milliseconds).</li>
                                <li><strong>setInterval()</strong> takes a callback function and a number specifying how often the callback function should execute.</li>
                            </ul>
                    </td>
                </tr>
                <tr>
                    <td class="vocab"><img src="./Images/event loop js.png" alt="diagram illustrating the event loop" class="example-img-tall"></td>
                    <td>Event Loop</td>
                    <td>At a high level, the event loop is a system for managing code execution. Input/output (I/O) is handled with events and callbacks so code execution can continue. We have data structures that we call the <strong>heap</strong> and the <strong>call stack</strong>, which are part of the JavaScript engine. The heap and call stack interact with <strong>Node and Web APIs</strong>, which pass messages back to the stack via an <strong>event queue</strong>. The event queue’s interaction with the call stack is managed by an <strong>event loop</strong>. All together, those parts maintain the order of code execution when we run asynchronous functions.
                        <br>
                        <br><ul>
                                <li>First the event loop will poll the stack to see if it is empty.</li>
                                <li>It will add the first waiting message.</li>
                                <li>It will repeat steps 1 and 2 until the stack has cleared.</li>
                            </ul>
                        <br>Using things like asynchronous callbacks, and methods like setTimeout() and setInterval(), JavaScript is still single-threaded, but the event loop is enabling something called <strong>concurrency</strong>.
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Concurrency</td>
                    <td>Two or more procedures are executed at the same time on the same shared resources. Since JavaScript is single-threaded, we’ll never have that flavor of “true” concurrency.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>The Heap</td>
                    <td>The heap is a block of memory where we store objects in an unordered manner. JavaScript variables and objects that are currently in use are stored in the heap.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>The Call Stack</td>
                    <td>The stack, or call stack, tracks what function is currently being run in your code.
                        <br>
                        <br>When you invoke a function, a <strong>frame</strong> is added to the stack. Frames connect that function’s arguments and local variables from the heap. Frames enter the stack in a last in, first out (LIFO) order.
                        <br>
                        <br>When you first initiate a program, the global execution context is added to the call stack, which contains the global variable and lexical environment. Each subsequent frame for a called function has a function execution context that includes the function’s lexical and variable environment.
                        <br>
                        <br>So when we say the call stack tracks what function is currently being run in our code, what we are tracking is the current execution context. When a function runs to completion, it is popped off of the call stack. The memory, or the frame, is cleared.
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>The Event Queue</td>
                    <td>The event queue is a <strong>list of messages corresponding to functions that are waiting to be processed</strong>. In the diagram, these messages are entering the event queue from sources such as various web APIs or async functions that were called and are returning additional events to be handled by the stack. Messages enter the queue in a first in, first out (FIFO) order. No code is executed in the event queue; instead, it holds functions that are waiting to be added back into the stack.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Promise</td>
                    <td><strong>Promises are objects that represent the eventual outcome of an asynchronous operation</strong>. A Promise object can be in one of three states:
                        <br>
                        <br><ul>
                                <li><strong>Pending:</strong> The initial state— the operation has not completed yet.</li>
                                <li><strong>Fulfilled:</strong> The operation has completed successfully and the promise now has a resolved value. For example, a request’s promise might resolve with a JSON object as its value.</li>
                                <li><strong>Rejected:</strong> The operation has failed and the promise has a reason for the failure. This reason is usually an Error of some kind.</li>
                            </ul>
                        <br>We refer to a promise as settled if it is no longer pending— it is either fulfilled or rejected.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">const executorFunction = (resolve, reject) => {
                        <br>&emsp;if (someCondition) {
                        <br>&emsp;&emsp;resolve('I resolved!');
                        <br>&emsp;} else {
                        <br>&emsp;&emsp;reject('I rejected!'); 
                        <br>&emsp;} 
                        <br>}
                        <br>
                        <br>const myFirstPromise = new Promise(executorFunction);
                    </td>
                    <td>Constructing a Promise</td>
                    <td>To create a new Promise object, we use the <strong>new</strong> keyword and the <strong>Promise</strong> constructor method. The Promise constructor method takes a function parameter called the <strong>executorFunction</strong> which runs automatically when the constructor is called. The executor function generally starts an asynchronous operation and dictates how the promise should be settled.
                        <br>
                        <br>The <strong>executorFunction</strong> has two function parameters, usually referred to as the <strong>resolve()</strong> and <strong>reject()</strong> functions. The resolve() and reject() functions <strong>aren’t defined by the programmer</strong>. When the Promise constructor runs, JavaScript will pass its own resolve() and reject() functions into the executor function.
                        <br>
                        <br><ul>
                                <li><strong>resolve()</strong> is a function with one argument. Under the hood, if invoked, resolve() will change the promise’s status from pending to fulfilled, and the promise’s resolved value will be set to the argument passed into resolve().</li>
                                <li><strong>reject()</strong> is a function that takes a reason or error as an argument. Under the hood, if invoked, reject() will change the promise’s status from pending to rejected, and the promise’s rejection reason will be set to the argument passed into reject().</li>
                            </ul>
                        <br>In practice, promises settle based on the results of asynchronous operations. For example, a database request may fulfill with the data from a query or reject with an error thrown. Most of the time, knowing how to consume, or use, promises will be key. Rather than constructing promises, you’ll be handling Promise objects returned to you as the result of an asynchronous operation. These promises will start off pending but settle eventually.
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Consuming Promises</td>
                    <td>The initial state of an asynchronous promise is <strong>pending</strong>, but we have a guarantee that it will settle. How do we tell the computer what should happen then? Promise objects come with an aptly named <strong>.then()</strong> method. It allows us to say, “I have a promise, when it settles, then here’s what I want to happen…”
                        <br>
                        <br><strong>.then()</strong> is a higher-order function— it takes two callback functions as arguments. We refer to these callbacks as handlers. When the promise settles, the appropriate handler will be invoked with that settled value. We can invoke .then() with one, both, or neither handler! This allows for flexibility, but it can also make for tricky debugging. If the appropriate handler is not provided, instead of throwing an error, .then() will just return a promise with the same settled value as the promise it was called on.
                        <br>
                        <br><ul>
                                <li>The first handler, sometimes called <strong>onFulfilled</strong>, is a <em>success handler</em>, and it should contain the logic for the promise resolving.</li>
                                <li>The second handler, sometimes called <strong>onRejected</strong>, is a <em>failure handler</em>, and it should contain the logic for the promise rejecting.</li>
                            </ul>
                    </td>
                </tr>
                <tr>
                    <td class="vocab"><img src="./Images/.then promise.png" alt="image of the .then promise code" class="example-img"></td>
                    <td>Success and Failure Callback Functions</td>
                    <td>To handle a “successful” promise, or a promise that resolved, we invoke .then() on the promise, passing in a success handler callback function.
                        <br>
                        <br>With typical promise consumption, we won’t know whether a promise will resolve or reject, so we’ll need to provide the logic for either case. We can pass both a success callback and a failure callback to .then(). To abide by the separation of concerns, use 2 different then() statements, one for success and one for failure.
                    </td>
                </tr>
                <tr>
                    <td class="vocab"><img src="./Images/catch promise.png" alt="an image of catch example code" class="example-img"></td>
                    <td>catch()</td>
                    <td>The <strong>.catch()</strong> function takes only <strong>one argument, onRejected</strong>. In the case of a rejected promise, this failure handler will be invoked with the reason for rejection. Using .catch() accomplishes the same thing as using a .then() with only a failure handler.
                        <br>
                        <br>In the example, if the promise rejects, .then() will return a promise with the same rejection reason as the original promise and .catch()‘s failure handler will be invoked with that rejection reason.
                    </td>
                </tr>
                <tr>
                    <td class="vocab"><img src="./Images/chaining promises.png" alt="an example of chaining promises in code" class="example-img"></td>
                    <td>Chaining Multiple Promises</td>
                    <td>The process of chaining promises together is called <em>composition</em>.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Avoiding Common Mistakes</td>
                    <td><ul>
                            <li>Nesting Promises instead of chaining them: this is ugly and messy to debug.</li>
                            <li>Forgetting to return a promise: since forgetting to return our promise won’t throw an error, this can be a really tricky thing to debug!</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td class="vocab"><img src="./Images/Promise.all().png" alt="example code using Promise.all()" class="example-img-tall"></td>
                    <td>Promise.all()</td>
                    <td>What if we’re dealing with multiple promises, but we don’t care about the order? <strong>Promise.all()</strong> accepts an array of promises as its argument and returns a single promise. That single promise will settle in one of two ways:
                        <br>
                        <br><ul>
                                <li><strong>If every promise in the argument array resolves</strong>, the single promise returned from Promise.all() will resolve with an array containing the resolve value from each promise in the argument array.</li>
                                <li><strong>If any promise from the argument array rejects</strong>, the single promise returned from Promise.all() will immediately reject with the reason that promise rejected. This behavior is sometimes referred to as <em>failing fast</em>.</li>
                            </ul>
                        <br>In the example, Promise.all() contains an array of three promises, which are the returned values from functions.
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>async...await</td>
                    <td>JavaScript is continually improving, and <strong>ES8</strong> provides a new syntax for handling our asynchronous action, <strong>async...await</strong>. The async...await syntax allows us to write asynchronous code that reads similarly to traditional synchronous, imperative programs (new syntax for promises and generators).</td>
                </tr>
                <tr>
                    <td class="vocab">async function myFunc() {
                        <br>&emsp;// Function body here
                        <br>};
                        <br>myFunc();
                        <br>
                        <br>const myFunc = async () => {
                        <br>&emsp;// Function body here
                        <br>};
                        <br>myFunc();
                        <br>
                        <br>async function fivePromise() { 
                        <br>&emsp;return 5;
                        <br>}
                        <br>
                        <br>fivePromise()
                        <br>&emsp;.then(resolvedValue => {
                        <br>&emsp;&emsp;console.log(resolvedValue);
                        <br>&emsp;})  // Prints 5
                    </td>
                    <td>async</td>
                    <td>The <strong>async</strong> keyword is used to write functions that handle asynchronous actions. We wrap our asynchronous logic inside a function prepended with the async keyword. Then, we invoke that function.
                        <br>
                        <br><strong>async functions always return a promise</strong>. This means we can use traditional promise syntax, like .then() and .catch with our async functions. An async function will return in one of three ways:
                        <br>
                        <br><ul>
                                <li>If there’s nothing returned from the function, it will return a promise with a resolved value of undefined.</li>
                                <li>If there’s a non-promise value returned from the function, it will return a promise resolved to that value.</li>
                                <li>If a promise is returned from the function, it will simply return that promise</li>
                            </ul>
                        <br>
                        <br>In the third example, even though we return 5 inside the function body, what’s actually returned when we invoke fivePromise() is a promise with a resolved value of 5.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">async function asyncFuncExample(){
                        <br>&emsp;let resolvedValue = await myPromise();
                        <br>&emsp;console.log(resolvedValue);
                        <br>}
                        <br>
                        <br>asyncFuncExample(); // Prints: I am resolved now!
                    </td>
                    <td>await</td>
                    <td><strong>async</strong> functions are almost always used with the additional keyword <strong>await</strong> inside the function body. The <em>await keyword can only be used inside an async function</em>. <strong>await is an operator: it returns the resolved value of a promise</strong>. Since promises resolve in an indeterminate amount of time, await halts, or pauses, the execution of our async function until a given promise is resolved.
                        <br>
                        <br>Within our async function, asyncFuncExample(), we use await to halt our execution until myPromise() is resolved and assign its resolved value to the variable resolvedValue.
                    </td>
                </tr>
                <tr>
                    <td class="vocab"><img src="./Images/async await dependent.png" alt="example of async await code" class="example-img"></td>
                    <td>Handling Dependent Promises</td>
                    <td>This async...await example more closely resembles synchronous code, which helps developers maintain and debug their code. The async...await syntax also makes it easy to store and refer to resolved values from promises further back in our chain which is a much more difficult task with native promise syntax.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td></td>
                    <td></td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td></td>
                    <td></td>
                </tr>
            </tbody>
        </table>

        <!-- Terminology -->
        <table>
            <thead>
                <tr>
                    <td colspan="3">Terminology</td> 
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th scope="col" class="example">Example</th>
                    <th scope="col" class="name">Name</th>
                    <th scope="col" class="description">Description</th>
                </tr>
                <tr>
                    <td class="vocab">console.log(5);</td>
                    <td>Console</td>
                    <td>The console is a panel that displays important messages, like errors, for developers. Much of the work the computer does with our code is invisible to us by default. If we want to see things appear on our screen, we can print, or log, to our console directly. In JavaScript, the <em>console</em> keyword refers to an object, a collection of data and actions, that we can use in our code. One action, or method, that is built into the <em>console</em> object is the <em>.log()</em> method. When we write <em>console.log()</em> what we put inside the parentheses will get printed, or logged, to the console. The example logs 5 to the console. The semicolon denotes the end of the line, or statement. Although in JavaScript your code will usually run as intended without a semicolon, we recommend ending each statement with a semicolon so you never leave one out in the few instances when they are required.</td>
                </tr>
                <tr>
                    <td class="vocab">// Prints 5 to the console ; <br> /*None of this is going to run!
                        console.log(99)*/</td>
                    <td>Comments</td>
                    <td>There are two types of code comments in JavaScript: a <em>single line comment</em> will comment out a single line and is denoted with two forward slashes // preceding it. You can also use a single line comment to comment after a line of code (on the same line). A <em>multi-line comment</em> will comment out multiple lines and is denoted with /* to begin the comment, and */ to end the comment. Single line comments are great for adding context to your code. Multi-line comments are often best suited to prevent a block of code from running.</td>
                </tr>
                <tr>
                    <td class="vocab">console.log('JavaScript');</td>
                    <td>Data Types</td>
                    <td>Data types are the classifications we give to the different kinds of data that we use in programming. In JavaScript, there are eight fundamental data types: 
                        <br>
                        <br><em>Number</em>: any number, including numbers with decimals: 4, 8, 1516, 23.42. 
                        <br>
                        <br><em>BigInt</em>: any number, greater than 2<sup>53</sup>-1 or less than -(2<sup>53</sup>-1), with n appended to the number: 1234567890123456n. 
                        <br>
                        <br><em>String</em>: any grouping of characters on your keyboard (letters, numbers, spaces, symbols, etc.) surrounded by single quotes: ' ... ' or double quotes " ... ", though we prefer single quotes. Some people like to think of <em>string</em> as a fancy word for text. 
                        <br>
                        <br><em>Boolean</em>: this data type only has two possible values— either true or false (without quotes). It’s helpful to think of booleans as on and off switches or as the answers to a “yes” or “no” question. 
                        <br>
                        <br><em>Null</em>: this data type represents the intentional absence of a value, and is represented by the keyword <em>null</em> (without quotes). 
                        <br>
                        <br><em>Undefined</em>: this data type is denoted by the keyword <em>undefined</em> (without quotes). It also represents the absence of a value though it has a different use than null. <em>undefined</em> means that a given value does not exist. 
                        <br>
                        <br><em>Symbol</em>: a newer feature to the language, symbols are unique identifiers, useful in more complex coding. 
                        <br>
                        <br><em>Object</em>: collections of related data.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">console.log(3 <strong>+</strong> 4);</td>
                    <td>Arithmetic Operators</td>
                    <td>An operator is a character that performs a task in our code. JavaScript has several built-in arithmetic operators, that allow us to perform mathematical calculations on numbers. These include the following operators and their corresponding symbols: <em>add (+)</em>, <em>subtract (-)</em>, <em>multiply (*)</em>, <em>divide (/)</em>, and <em>remainder (%)</em>. The example will print 7. If we wanted to print the characters 3 + 4, we would wrap them in quotes and print them as a string. The <em>remainder operator</em>, sometimes called <em>modulo</em>, returns the number that remains after the right-hand number divides into the left-hand number as many times as it evenly can: <em>11 % 3</em> equals 2 because 3 fits into 11 three times, leaving 2 as the remainder.</td>
                </tr>
                <tr>
                    <td class="vocab">console.log(<strong>'I love to ' + 'code.'</strong>);</td>
                    <td>String Concatenation</td>
                    <td>When a + operator is used on two strings, it appends the right string to the left string. The example prints, I love to code. Notice that we had to include a space at the end of the first string. The computer will join the strings exactly, so we needed to make sure to include the space we wanted between the two strings. Note: if there’s a single quote character, ', in our string, we can use double quotes around the string to make sure the character prints.</td>
                </tr>
                <tr>
                    <td class="vocab">console.log('Hello'<strong>.length</strong>);</td>
                    <td>Properties</td>
                    <td>When you introduce a new piece of data into a JavaScript program, the browser saves it as an instance of the data type. All data types have access to specific properties that are passed down to each instance. For example, every string instance has a property called length that stores the number of characters in that string. You can retrieve property information by appending the string with a period and the property name (see example). The example prints "5", the number of characters (length) of "Hello". The . is another operator! We call it the <em>dot operator</em>.</td>
                </tr>
                <tr>
                    <td class="vocab">console.log('Codecademy'<strong>.toUpperCase()</strong>);</td>
                    <td>Methods</td>
                    <td>Actions we can perform. Data types have access to specific methods that allow us to handle instances of that data type. JavaScript provides a number of string methods. We <em>call</em>, or use, these methods by appending an instance with: a period (the dot operator .), the name of the method (toUpperCase), and opening and closing parentheses. When we use console.log() we’re calling the .log() method on the console object. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">Learn more here</a>.</td>
                </tr>
                <tr>
                    <td class="vocab">console.log(Math.random());</td>
                    <td>Built-in Objects</td>
                    <td>Console is an example of a built-in object. You can also build your own objects. In the example, <em>console</em> is an object, <em>Math</em> is an object, and <em>random</em> is a method. The example prints a random number between 0 and 1. To generate a random number between 0 and 50, we could multiply this result by 50, like so: <em>Math.random() * 50;</em>. The example above will likely evaluate to a decimal. To ensure the answer is a whole number, we can take advantage of another useful Math method called Math.floor() - <em>Math.floor(Math.random() * 50);</em>. <em>Math.floor()</em> takes a decimal number, and rounds down to the nearest whole number. If you wanted to see the number printed to the terminal, you would still need to use a <em>console.log()</em> statement: <em>console.log(Math.floor(Math.random() * 50));</em>. <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects">Learn more here</a>.</td>
                </tr>
            </tbody>
        </table>

        <!-- Variables -->
        <table>
            <thead>
                <tr>
                    <td colspan="3">Variables</td> 
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th scope="col" class="example">Example</th>
                    <th scope="col" class="name">Name</th>
                    <th scope="col" class="description">Description</th>
                </tr>
                <tr>
                    <td class="vocab">var myName = 'Arya'; 
                        <br>console.log(myName); 
                        <br>// Output: Arya
                        <br>
                        <br><strong>let</strong> and <strong>const</strong> are preferred over var
                    </td>
                    <td>Variables</td>
                    <td>In the example, <em>var</em>, short for variable, is a JavaScript keyword that creates, or declares, a new variable. <em>myName</em> is the variable’s name. Capitalizing in this way is a standard convention in JavaScript called <em>camel casing</em>. In camel casing you group words into one, the first word is lowercase, then every word that follows will have its first letter uppercased. <em>=</em> is the assignment operator. It assigns the <em>value</em> ('Arya') to the <em>variable</em> (myName). You can also say that the myName variable is <em>initialized</em> with a value of 'Arya'. After the variable is declared, the string value 'Arya' is printed to the console by referencing the variable name: console.log(myName). 
                        <br> 
                        <br><em>Rules for naming variables</em>:
                        <br> 
                        <br><ul>
                                <li>Variable names cannot start with numbers.</li>
                                <li>Variable names are case sensitive, so myName and myname would be different variables. It is bad practice to create two variables that have the same name using different cases.</li>
                                <li>Variable names cannot be the same as keywords.</li>
                            </ul>
                    </td>
                </tr>
                <tr>
                    <td class="vocab">let meal = 'Enchiladas';
                        <br>
                        <br>console.log(meal); 
                        <br>// Output: Enchiladas
                        <br>
                        <br>meal = 'Burrito';
                        <br>
                        <br>console.log(meal); 
                        <br>// Output: Burrito
                    </td>
                    <td>let</td>
                    <td>The <em>let</em> keyword signals that the variable can be reassigned a different value. Another concept that we should be aware of when using let (and even var) is that we can declare a variable without assigning the variable a value. In such a case, the variable will be automatically initialized with a value of <em>undefined</em>.
                    <br>
                    <br>let price; 
                    <br>console.log(price); // Output: undefined
                    <br>price = 350;
                    <br>console.log(price); // Output: 350
                    </td>
                </tr>
                <tr>
                    <td class="vocab">const myName = 'Gilberto';
                        <br>console.log(myName); 
                        <br>// Output: Gilberto
                    </td>
                    <td>const</td>
                    <td>Short for the word <em>constant</em>. A const variable cannot be reassigned because it is constant. If you try to reassign a const variable, you’ll get a TypeError. Constant variables must be assigned a value when declared. If you try to declare a const variable without a value, you’ll get a SyntaxError. If you need to reassign the variable, use <em>let</em>, otherwise use <em>const</em>.</td>
                </tr>
                <tr>
                    <td class="vocab">let w = 4;
                                  <br>w = w + 1;
                                  <br>console.log(w); 
                                  <br>// Output: 5
                                  <br>
                                  <br>let w = 4;
                                  <br>w += 1;
                                  <br>console.log(w); 
                                  <br>// Output: 5
                                  <br>
                                  <br>let a = 10;
                                  <br>a++;
                                  <br>console.log(a); 
                                  <br>// Output: 11
                    </td>
                    <td>Mathematical Assignment Operators</td>
                    <td>In the second example, we used the += <em>assignment operator</em> to reassign w. We’re performing the mathematical operation of the first operator + using the number to the right, then reassigning w to the computed value. We also have access to other mathematical assignment operators: -=, *=, and /= which work in a similar fashion. Other mathematical assignment operators include the <em>increment operator</em> (++) and <em>decrement operator</em> (--). The increment operator will increase the value of the variable by 1. The decrement operator will decrease the value of the variable by 1.</td>
                </tr>
                <tr>
                    <td class="vocab">let myPet = 'armadillo';
                                  <br>console.log('I own a pet ' + myPet + '.'); 
                                  <br>// Output: 'I own a pet armadillo.'
                    </td>
                    <td>String Concatenation with Variables</td>
                    <td>The + operator can be used to combine two string values even if those values are being stored in variables.</td>
                </tr>
                <tr>
                    <td class="vocab">const myPet = 'armadillo';
                                  <br>console.log(`I own a pet ${myPet}.`);
                                  <br>// Output: I own a pet armadillo.
                    </td>
                    <td>String Interpolation</td>
                    <td>In the ES6 version of JavaScript, we can insert, or <em>interpolate</em>, variables into strings using <em>template literals</em>. Notice: a template literal is wrapped by backticks ` (this key is usually located on the top of your keyboard, left of the 1 key). Inside the template literal, you’ll see a placeholder, ${myPet}. The value of myPet is inserted into the template literal.</td>
                </tr>
                <tr>
                    <td class="vocab">const unknown1 = 'foo';
                                  <br>console.log(typeof unknown1); 
                                  <br>// Output: string
                                  <br>
                                  <br>if (typeof variableName === 'number') {}
                    </td>
                    <td>typeof operator</td>
                    <td>While writing code, it can be useful to keep track of the data types of the variables in your program. If you need to check the data type of a variable’s value, you can use the <em>typeof operator</em>. The typeof operator checks the value to its right and returns, or passes back, a string of the data type.</td>
                </tr>
            </tbody>
        </table>

        <!-- Conditionals -->
        <table>
            <thead>
                <tr>
                    <td colspan="3">Conditionals</td> 
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th scope="col" class="example">Example</th>
                    <th scope="col" class="name">Name</th>
                    <th scope="col" class="description">Description</th>
                </tr>
                <tr>
                    <td class="vocab">if (true) {
                        <br>console.log('This message will print!'); 
                        <br>}
                        <br>// Prints: This message will print!
                    </td>
                    <td>if</td>
                    <td>The <em>if</em> statement is composed of: the <em>if</em> keyword followed by a set of parentheses () which is followed by a <em>code block</em>, or block statement, indicated by a set of curly braces {}. Inside the parentheses (), a condition is provided that evaluates to <em>true</em> or <em>false</em>. If the condition evaluates to true, the code inside the curly braces {} runs, or executes. If the condition evaluates to false, the block won’t execute.</td>
                </tr>
                <tr>
                    <td class="vocab">if (false) {
                        <br>console.log('The code in this block will not run.');
                        <br>} else {
                        <br>console.log('But the code in this block will!');
                        <br>}
                        <br>// Prints: But the code in this block will!
                    </td>
                    <td>else</td>
                    <td>In many cases, we’ll have code we want to run if our condition evaluates to false. An <em>else</em> statement must be paired with an <em>if</em> statement, and together they are referred to as an <em>if...else</em> statement. <em>if...else</em> statements allow us to automate solutions to yes-or-no questions, also known as <em>binary decisions</em>.</td>
                </tr>
                <tr>
                    <td class="vocab">let stopLight = 'yellow';
                        <br>
                        <br>if (stopLight === 'red') {
                        <br>console.log('Stop!');
                        <br>} else if (stopLight === 'yellow') {
                        <br>console.log('Slow down.');
                        <br>} else if (stopLight === 'green') {
                        <br>console.log('Go!');
                        <br>} else {
                        <br>console.log('Caution, unknown!');
                        <br>}
                    </td>
                    <td>else if</td>
                    <td>We can add more conditions to our <em>if...else</em> with an <em>else if</em> statement. The else if statement allows for more than two possible outcomes. You can add as many else if statements as you’d like, to make more complex conditionals! <em>The else if statement always comes after the if statement and before the else statement.</em> The else if statement <em>also takes a condition</em>. <em>if/else if/else</em> statements are read from top to bottom, so the first condition that evaluates to true from the top to bottom is the block that gets executed.</td>
                </tr>
                <tr>
                    <td class="vocab">isNightTime ? 
                        <br>console.log('Turn on the lights!') 
                        <br>: console.log('Turn off the lights!');
                    </td>
                    <td>Ternary Operator</td>
                    <td>Can simplify an <em>if...else</em> statement. The condition, <em>isNightTime</em>, is provided before the <em>?</em>. Two expressions follow the ? and are separated by a colon : ... If the condition evaluates to true, the first expression executes. If the condition evaluates to false, the second expression executes.</td>
                </tr>
                <tr>
                    <td class="vocab">Less than: &lt;
                        <br>Greater than: &gt;
                        <br>Less than or equal to: &lt;=
                        <br>Greater than or equal to: &gt;=
                        <br>Is equal to: ===
                        <br>Is not equal to: !==
                        <br>
                        <br>10 &lt; 12 
                        <br>// Evaluates to true
                    </td>
                    <td>Comparison Operators</td>
                    <td>When writing conditional statements, sometimes we need to use different types of operators to compare values. These operators are called <em>comparison operators</em>. Comparison operators compare the value on the left with the value on the right. All comparison statements evaluate to either true or false and are made up of: two values that will be compared, and an operator that separates the values and compares them accordingly (&gt;, &lt;, &lt;=, &gt;=, ===, !==). Note that "==" indicates <em>loose equality</em>.</td>
                </tr>
                <tr>
                    <td class="vocab">if (stopLight === 'green' && pedestrians === 0) {
                        <br>console.log('Go!');
                        <br>} else {
                        <br>console.log('Stop');
                        <br>}
                        <br>
                        <br>if (day === 'Saturday' || day === 'Sunday') {
                        <br>console.log('Enjoy the weekend!');
                        <br>} else {
                        <br>console.log('Do some work.');
                        <br>}
                        <br>
                        <br>let excited = true;
                        <br>console.log(!excited); 
                        <br>// Prints false
                        <br>let sleepy = false;
                        <br>console.log(!sleepy); 
                        <br>// Prints true
                    </td>
                    <td>Logical Operators</td>
                    <td>In JavaScript, there are operators that work with <em>boolean</em> values known as <em>logical operators</em>. We can use logical operators to add more sophisticated logic to our conditionals. There are three logical operators: the <em>and</em> operator (&&), the <em>or</em> operator (||), and the <em>not</em> operator, otherwise known as the <em>bang</em> operator (!). When we use the <em>&&</em> operator, we are checking that <em>two things are both true</em>. When we use the <em>||</em> operator, we are checking that <em>either of two things are true</em>. If the first condition in an || statement evaluates to true, the second condition won’t even be checked. The ! <em>not</em> operator reverses, or negates, the value of a boolean. Essentially, the ! operator will either take a true value and pass back false, or it will take a false value and pass back true.</td>
                </tr>
                <tr>
                    <td class="vocab">let myVariable = 'I Exist!';
                        <br>
                        <br>if (myVariable) {
                        <br>console.log(myVariable)
                        <br>} else {
                        <br>console.log('The variable does not exist.')
                        <br>}
                    </td>
                    <td>Truthy & Falsy</td>
                    <td>Sometimes, you’ll want to check if a variable exists and you won’t necessarily want it to equal a specific value — you’ll only check to see if the variable has been assigned a value. The list of <em>falsy</em> values includes: <em>0</em>, <em>empty strings like "" or ''</em>, <em>null</em>, which represents when there is no value at all, <em>undefined</em>, which represents when a declared variable lacks a value, and <em>NaN</em>, or Not a Number.</td>
                </tr>
                <tr>
                    <td class="vocab">let groceryItem = 'papaya';
                        <br>
                        <br>switch (groceryItem) {
                        <br> &nbsp;case 'tomato':
                        <br> &emsp;  console.log('Tomatoes are $0.49');
                        <br> &emsp;  break;
                        <br>&nbsp;case 'lime':
                        <br>&emsp;  console.log('Limes are $1.49');
                        <br>&emsp;  break;
                        <br>&nbsp;case 'papaya':
                        <br>&emsp;  console.log('Papayas are $1.29');
                        <br>&emsp;  break;
                        <br>&nbsp;default:
                        <br>&emsp;  console.log('Invalid item');
                        <br>&emsp;  break;
                        <br>}
                        <br>
                        <br>// Prints 'Papayas are $1.29'
                    </td>
                    <td>switch</td>
                    <td>A <em>switch</em> statement provides an alternative syntax that is easier to read and write. The <em>switch</em> keyword initiates the statement and is followed by ( ... ), which contains the value that each case will compare. In the example, the <em>value</em> or expression of the switch statement is <em>groceryItem</em>. Inside the block, { ... }, there are multiple <em>cases</em>. The <em>case</em> keyword checks if the expression matches the specified value that comes after it. The value following the first case is 'tomato'. If the value of groceryItem equalled 'tomato', that case‘s console.log() would run. The value of groceryItem is 'papaya', so the third case runs— Papayas are $1.29 is logged to the console. The <em>break</em> keyword tells the computer to exit the block and <em>not execute any more code or check any other cases</em> inside the code block. Note: Without break keywords, the first matching case will run, but so will every subsequent case regardless of whether or not it matches—including the default. This behavior is different from <em>if/else</em> conditional statements that execute only one block of code. At the end of each switch statement, there is a <em>default</em> statement. If none of the cases are true, then the code in the default statement will run.</td>
                </tr>
            </tbody>
        </table>

        <!-- Functions -->
        <table>
            <thead>
                <tr>
                    <td colspan="3">Functions</td> 
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th scope="col" class="example">Example</th>
                    <th scope="col" class="name">Name</th>
                    <th scope="col" class="description">Description</th>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Function</td>
                    <td>A function is a reusable block of code that groups together a sequence of statements to perform a specific task.</td>
                </tr>
                <tr>
                    <td class="vocab">function greetWorld() {
                        <br>console.log('Hello, World!');
                        <br>}
                    </td>
                    <td>Function Declaration</td>
                    <td>Just like how a variable declaration binds a value to a variable name, a <em>function declaration</em> binds a function to a name, or an <em>identifier</em>. A function declaration consists of: <em>the function keyword</em>, the name of the function, or its <em>identifier</em>, followed by parentheses, and <em>a function body</em>, or the block of statements required to perform a specific task, enclosed in the function’s curly brackets, { }.</td>
                </tr>
                <tr>
                    <td class="vocab">greetWorld();
                        <br>// Output: Hello, World!
                        <br>
                        <br>function greetWorld() {
                        <br>console.log('Hello, World!');
                        <br>}
                    </td>
                    <td>Hoisting</td>
                    <td>Allows access to function declarations before they’re defined. Since hoisting isn’t considered good practice, we simply want you to be aware of this feature.</td>
                </tr>
                <tr>
                    <td class="vocab">greetWorld ();</td>
                    <td>Calling a Function</td>
                    <td>A function declaration does not ask the code inside the function body to run, it just declares the existence of the function. The code inside a function body runs, or executes, only when the function is called. To call a function in your code, you type the function name followed by parentheses. This function call executes the function body, or all of the statements between the curly braces in the function declaration.</td>
                </tr>
                <tr>
                    <td class="vocab">function calculateArea<strong>(width, height)</strong> {
                        <br>console.log(width * height);
                        <br>}
                    </td>
                    <td>Parameters</td>
                    <td>Some functions can take inputs and use the inputs to perform a task. When declaring a function, we can specify its <em>parameters</em>. Parameters allow functions to accept input(s) and perform a task using the input(s). We use parameters as <strong>placeholders for information that will be passed to the function when it is called</strong>. The parameters are specified between the parenthesis as width and height, and inside the function body, they act just like regular variables. width and height act as placeholders for values that will be multiplied together.</td>
                </tr>
                <tr>
                    <td class="vocab">calculateArea(<strong>10, 6</strong>);</td>
                    <td>Arguments</td>
                    <td>The values that are passed to the function when it is called are called <em>arguments</em>. Arguments can be passed to the function as values or variables (names need to be surrounded by ' '). In the function call above, the number 10 is passed as the width and 6 is passed as height. Notice that the order in which arguments are passed and assigned follows the order that the parameters are declared.</td>
                </tr>
                <tr>
                    <td class="vocab">function greeting 
                        <br>(name = 'stranger') {
                        <br>console.log(`Hello, ${name}!`)
                        <br>}
                        <br>greeting() // Output: Hello, stranger!
                    </td>
                    <td>Default Parameters</td>
                    <td>One of the features added in ES6 is the ability to use <em>default parameters</em>. Default parameters allow parameters to have a predetermined value in case there is no argument passed into the function or if the argument is undefined when called. In the example, we used the = operator to assign the parameter name a default value of 'stranger'. When there isn’t an argument passed into greeting(), the default value of 'stranger' is used, and 'Hello, stranger!' is logged to the console.</td>
                </tr>
                <tr>
                    <td class="vocab">function monitorCount 
                        <br>(rows, columns) {
                        <br>return rows * columns;
                        <br>}
                        <br>
                        <br>const numOfMonitors = monitorCount(5, 4);
                        <br>
                        <br>console.log(numOfMonitors);
                    </td>
                    <td>return</td>
                    <td>When a function is called, the computer will run through the function’s code and evaluate the result of calling the function. By default that resulting value is undefined. To pass back information from the function call, we use a <em>return statement</em>. To create a return statement, we use the return keyword followed by the value that we wish to return. If the value is omitted, undefined is returned instead. When a return statement is used in a function body, the execution of the function is stopped and the code that follows it will not be executed. The return keyword is powerful because it allows functions to produce an output. We can then save the output to a variable for later use.</td>
                </tr>
                <tr>
                    <td class="vocab">function multiplyByNineFifths(number) {
                        <br>return number * (9/5);
                        <br>};
                        <br>
                        <br>function getFahrenheit(celsius) {
                        <br>return multiplyByNineFifths(celsius) + 32;
                        <br>};
                        <br>
                        <br>getFahrenheit(15); // Returns 59
                    </td>
                    <td>Helper Functions</td>
                    <td>We can also use the return value of a function inside another function. These functions being called within another function are often referred to as <em>helper functions</em>. Since each function is carrying out a specific task, it makes our code easier to read and debug if necessary. <strong>In the example</strong>, getFahrenheit() is called and 15 is passed as an argument. The code block inside of getFahrenheit() calls multiplyByNineFifths() and passes 15 as an argument. multiplyByNineFifths() takes the argument of 15 for the number parameter. The code block inside of multiplyByNineFifths() function multiplies 15 by (9/5), which evaluates to 27. 27 is returned back to the function call in getFahrenheit(). getFahrenheit() continues to execute. It adds 32 to 27, which evaluates to 59. Finally, 59 is returned back to the function call getFahrenheit(15). Writing helper functions can help take large and difficult tasks and break them into smaller and more manageable tasks.</td>
                </tr>
                <tr>
                    <td class="vocab">const calculateArea
                        <br>= function(width, height) {
                        <br>}
                    </td>
                    <td>Function Expression</td>
                    <td>Another way to define a function is to use a <em>function expression</em>. To define a function inside an expression, we can use the function keyword. In a function expression, the function name is usually omitted. A function with no name is called an <em>anonymous function</em>. A function expression is often stored in a variable in order to refer to it. <strong>To declare a function expression:</strong> declare a variable to be the name, or identifier, of your function. Since the release of ES6, it is common practice to use const as the keyword to declare the variable. Assign as that variable’s value an anonymous function created by using the function keyword followed by a set of parentheses with possible parameters. Then a set of curly braces that contain the function body. <strong>To invoke a function expression</strong>, write the name of the variable in which the function is stored followed by parentheses enclosing any arguments being passed into the function.</td>
                </tr>
                <tr>
                    <td class="vocab">const rectangleArea = 
                        <br>(width, height) => {
                        <br>let area = width * height;
                        <br>return area;
                        <br>};
                    </td>
                    <td>Arrow Functions</td>
                    <td>ES6 introduced <em>arrow function syntax</em>, a shorter way to write functions by using the special “fat arrow” () => notation. Arrow functions remove the need to type out the keyword function every time you need to create a function. Instead, you first include the parameters inside the ( ) and then add an arrow => that points to the function body surrounded in { }.</td>
                </tr>
                <tr>
                    <td class="vocab">const squareNum = (num) => {
                        <br>return num * num;
                        <br>};
                        <br>
                        <br>const squareNum = num => num * num;
                    </td>
                    <td>Concise Body Arrow Functions</td>
                    <td>JavaScript also provides several ways to refactor arrow function syntax. The most condensed form of the function is known as <em>concise body</em>. <strong>Rules</strong>: Functions that take only a single parameter do not need that parameter to be enclosed in parentheses. However, if a function takes zero or multiple parameters, parentheses are required. A function body composed of a single-line block does not need curly braces. Without the curly braces, whatever that line evaluates will be automatically returned. The contents of the block should immediately follow the arrow => and the return keyword can be removed. This is referred to as <em>implicit return</em>.
                        <br>
                        <br><strong>If you include curly brackets {}, you must type return in the code block. If you do <em>not</em> include curly braces {}, do <em>not</em> type return.</strong>
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Higher Order Functions</td>
                    <td><em>Higher-order functions</em> are functions that accept other functions as arguments and/or return functions as output. This enables us to build abstractions on other abstractions.</td>
                </tr>
                <tr>
                    <td class="vocab">const announceThatIAmDoingImportantWork = () => {
                        <br>console.log("I’m doing very important work!");
                        <br>};
                        <br>
                        <br>const busy = announceThatIAmDoingImportantWork;
                        <br>busy(); // This function call barely takes any space!
                    </td>
                    <td>Functions as Data</td>
                    <td>JavaScript functions behave like any other data type in the language; we can assign functions to variables, and we can reassign them to new variables. This is especially helpful if we want to maintain the source code for a function.
                        <br>
                        <br>busy is a variable that holds a reference to our original function. If we could look up the address in memory of busy and the address in memory of announceThatIAmDoingImportantWork they would point to the same place. Our new busy() function can be invoked with parentheses as if that was the name we originally gave our function. Notice how we assign announceThatIAmDoingImportantWork without parentheses as the value to the busy variable. We want to assign the value of the function itself, not the value it returns when invoked.
                        <br>
                        <br><strong>In JavaScript, functions are first class objects</strong>. This means that, like other objects you’ve encountered, JavaScript functions can have properties and methods. Since functions are a type of object, they have properties such as .length and .name, and methods such as .toString().
                    </td>
                </tr>
                <tr>
                    <td class="vocab">const higherOrderFunc = param => {
                        <br>&nbsp;param();
                        <br>&nbsp;return `I just invoked ${param.name} as a callback function!`
                        <br>}
                        <br>
                        <br>const anotherFunc = () => {
                        <br>&nbsp;return 'I\'m being invoked by the higher-order function!';
                        <br>}
                        <br>
                        <br>higherOrderFunc(anotherFunc);
                    </td>
                    <td>Functions as Parameters</td>
                    <td>A <em>parameter</em> is a placeholder for the data that gets passed into a function. Since functions can behave like any other type of data in JavaScript, it might not surprise you to learn that functions can accept other functions as parameters. A <em>higher-order function</em> is a function that either accepts functions as parameters, returns a function, or both! We call functions that get passed in as parameters <em>callback functions</em>. Callback functions get invoked during the execution of the higher-order function.
                        <br>
                        <br>When we invoke a higher-order function, and pass another function in as an argument, we don’t invoke the argument function. Invoking it would evaluate to passing in the return value of that function call. <em>With callback functions, we pass in the function itself by typing the function name without the parentheses</em> (see example).
                    </td>
                </tr>
            </tbody>
        </table>

        <!-- Objects -->
        <table>
            <thead>
                <tr>
                    <td colspan="3">Objects</td> 
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th scope="col" class="example">Example</th>
                    <th scope="col" class="name">Name</th>
                    <th scope="col" class="description">Description</th>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Objects</td>
                    <td>At their core, JavaScript objects are containers storing related data and functionality. Objects are <em>mutable</em> meaning we can update them after we create them!</td>
                </tr>
                <tr>
                    <td class="vocab">let spaceship = {}; 
                        <br>// spaceship is an empty object
                        <br>
                        <br>// An object literal with two key-value pairs
                        <br>let spaceship = {
                        <br>'Fuel Type': 'diesel',
                        <br>color: 'silver'
                        <br>};
                    </td>
                    <td>Object Literals</td>
                    <td>Objects can be assigned to variables just like any JavaScript type. We use curly braces, {}, to designate an <em>object literal</em>.
                        <br>
                        <br>We fill an object with unordered data. This data is organized into <em>key-value pairs</em>. A key is like a variable name that points to a location in memory that holds a value. A key’s value can be of any data type in the language including functions or other objects.
                        <br>
                        <br>We make a key-value pair by writing the key’s name, or identifier, followed by a colon and then the value. We separate each key-value pair in an object literal with a comma (,). Keys are strings, but when we have a key that does not have any special characters in it, JavaScript allows us to omit the quotation marks.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">let spaceship = {
                        <br>&nbsp;homePlanet: 'Earth',
                        <br>&nbsp;color: 'silver'
                        <br>};
                        <br>
                        <br>spaceship.homePlanet; 
                        <br>// Returns 'Earth'
                        <br>
                        <br>let spaceship = {
                        <br>&nbsp;'Fuel Type': 'Turbo Fuel'
                        <br>};
                        <br>
                        <br>spaceship['Fuel Type'];
                        <br>// Returns  'Turbo Fuel'
                    </td>
                    <td>Accessing Properties</td>
                    <td>There are two ways we can access an object’s property: 
                        <br>
                        <br><em>dot notation (.)</em>: With property dot notation, we write the object’s name, followed by the dot operator and then the property name (key).
                        <br>
                        <br><em>bracket notation []</em>: To use bracket notation to access an object’s property, we pass in the property name (key) as a string. We <strong>must</strong> use bracket notation when accessing keys that have <strong>numbers, spaces, or special characters</strong> in them. Without bracket notation in these situations, our code would throw an error. With bracket notation you can also use a variable inside the brackets to select the keys of an object. This can be especially helpful when working with functions.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">const spaceship = {type: 'shuttle'};
                        <br>
                        <br>spaceship = {type: 'alien'}; 
                        <br>// TypeError: Assignment to constant variable.
                        <br>
                        <br>spaceship.type = 'alien'; 
                        <br>// Changes the value of the type property
                        <br>
                        <br>spaceship.speed = 'Mach 5'; 
                        <br>// Creates a new key of 'speed' with a value of 'Mach 5'
                        <br>
                        <br>delete spaceship.mission;  
                        <br>// Removes the mission property
                    </td>
                    <td>Property Assignment</td>
                    <td>We can use either dot notation, ., or bracket notation, [], and the assignment operator, = to add new key-value pairs to an object or change an existing property. One of two things can happen with property assignment: if the property already exists on the object, whatever value it held before will be replaced with the newly assigned value; if there was no property with that name, a new property will be added to the object. It’s important to know that although we can’t reassign an object declared with const, we can still mutate it, meaning we can add new properties and change the properties that are there.
                        <br>
                        <br>You can delete a property from an object with the <em>delete</em> operator.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">const alienShip = {
                        <br>&nbsp;invade () { 
                        <br>&nbsp;&nbsp;console.log('Hello! We have come to dominate your planet. Instead of Earth, it shall be called New Xaculon.')
                        <br>&nbsp;},
                        <br>&nbsp;takeOff () {
                        <br>&nbsp;&nbsp;console.log('Spim... Borp... Glix... Blastoff!');
                        <br>&nbsp;}
                        <br>};
                        <br>
                        <br>alienShip.invade();
                    </td>
                    <td>Methods</td>
                    <td>We can include methods in our object literals by creating ordinary, colon-separated key-value pairs. The key serves as our method’s name, while the value is an anonymous function expression.
                        <br>
                        <br>With the new method syntax introduced in ES6 we can omit the colon and the function keyword. Don’t forget to separate your methods with commas just as you would any other key-value pairs.
                        <br>
                        <br>Object methods are invoked by appending the object’s name with the dot operator (.) followed by the method name and parentheses. 
                    </td>
                </tr>
                <tr>
                    <td class="vocab">const spaceship = {
                        <br>&nbsp;crew: {
                        <br>&nbsp;&nbsp;captain: { 
                        <br>&nbsp;&nbsp;&nbsp;name: 'Sandra', 
                        <br>&nbsp;&nbsp;&nbsp;degree: 'Computer Engineering', 
                        <br>&nbsp;&nbsp;&nbsp;encourageTeam() { console.log('We got this!') } 
                        <br>&nbsp;&nbsp;}
                        <br>&nbsp;}
                        <br>}; 
                        <br>
                        <br>spaceship.crew.captain.name; 
                        <br>// Returns 'Sandra'
                    </td>
                    <td>Nested Objects</td>
                    <td>In application code, objects are often nested— an object might have another object as a property which in turn could have a property that’s an array of even more objects!
                        <br>
                        <br>We can chain operators to access nested properties. We’ll have to pay attention to which operator makes sense to use in each layer. It can be helpful to pretend you are the computer and evaluate each expression from left to right so that each operation starts to feel a little more manageable.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">const spaceship = {
                        <br>&nbsp;homePlanet : 'Earth',
                        <br>&nbsp;color : 'silver'
                        <br>};
                        <br>
                        <br>let paintIt = obj => {
                        <br>&nbsp;obj.color = 'glorious gold'
                        <br>};
                        <br>
                        <br>paintIt(spaceship);
                        <br>
                        <br>spaceship.color 
                        <br>// Returns 'glorious gold'
                    </td>
                    <td>Pass By Reference</td>
                    <td>Objects are <em>passed by reference</em>. This means when we pass a variable assigned to an object into a function as an argument, the computer interprets the parameter name as pointing to the space in memory holding that object. As a result, functions which change object properties actually mutate the object permanently (even when the object is assigned to a const variable).</td>
                </tr>
                <tr>
                    <td class="vocab">// for...in
                        <br>for (let crewMember in spaceship.crew) {
                        <br>&nbsp;console.log(`${crewMember}: 
                        <br>${spaceship.crew[crewMember].name}`);
                        <br>}
                        <br>
                        <br>for (let variableName in outerObject.innerObject) {
                        <br>&nbsp;console.log(`${outerObject.innerObject[variableName].propertyName}: ${outerObject.innerObject[variableName].differentPropertyName}`)
                        <br>};
                    </td>
                    <td>Looping Through Objects</td>
                    <td>We learned how to iterate through arrays using their numerical indexing, but the key-value pairs in objects aren’t ordered! JavaScript has given us alternative solution for iterating through objects with the <em><strong>for...in</strong></em> syntax. <em>for...in</em> will execute a given block of code for each property in an object. Our for...in will iterate through each element of the spaceship.crew object. In each iteration, the variable crewMember is set to one of spaceship.crew‘s keys, enabling us to log a list of crew members’ role and name.</td>
                </tr>
                <tr>
                    <td class="vocab">const goat = {
                        <br>&nbsp;dietType: 'herbivore',
                        <br>&nbsp;makeSound() {
                        <br>&nbsp;&nbsp;console.log('baaa');
                        <br>&nbsp;},
                        <br>&nbsp;diet() {
                        <br>&nbsp;&nbsp;console.log(<strong>this</strong>.dietType);
                        <br>&nbsp;}
                        <br>};
                        <br>
                        <br>goat.diet(); 
                        <br>// Output: herbivore
                    </td>
                    <td>this</td>
                    <td>The <em>this</em> keyword references the calling object which provides access to the calling object’s properties. In the example, the calling object is <em>goat</em>, and the property is <em>dietType</em>.</td>
                </tr>
                <tr>
                    <td class="vocab">const goat = {
                        <br>&nbsp;dietType: 'herbivore',
                        <br>&nbsp;makeSound() {
                        <br>&nbsp;&nbsp;console.log('baaa');
                        <br>&nbsp;},
                        <br>&nbsp;<strong>diet: () =></strong> {
                        <br>&nbsp;&nbsp;console.log(<strong>this</strong>.dietType);
                        <br>&nbsp;}
                        <br>};
                        <br>
                        <br>goat.diet(); 
                        <br>// Prints undefined
                    </td>
                    <td>Arrow Functions and this</td>
                    <td>Avoid using arrow functions when using <em>this</em> in a method.</td>
                </tr>
                <tr>
                    <td class="vocab">const bankAccount = {
                        <br>&nbsp;_amount: 1000
                        <br>}
                    </td>
                    <td>Privacy</td>
                    <td>When discussing privacy in objects, we define it as the idea that only certain properties should be mutable or able to change in value. Certain languages have privacy built-in for objects, but JavaScript does not have this feature. 
                        <br>
                        <br>Rather, JavaScript developers follow naming conventions that signal to other developers how to interact with a property. One common convention is to <strong>place an underscore _ before the name of a property to mean that the property should not be altered</strong>. Though the property <em>can</em> be altered (i.e. bankAccount._amount = 1000000;), developers communicate not to do so.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">const person = {
                        <br>&nbsp;_firstName: 'John',
                        <br>&nbsp;_lastName: 'Doe',
                        <br>&nbsp;get fullName() {
                        <br>&nbsp;&nbsp;if (this._firstName && this._lastName){
                        <br>&nbsp;&nbsp;&nbsp;return `${this._firstName} ${this._lastName}`;
                        <br>&nbsp;&nbsp;} else {
                        <br>&nbsp;&nbsp;&nbsp;return 'Missing a first name or a last name.';
                        <br>&nbsp;&nbsp;}
                        <br>&nbsp;}
                        <br>}
                        <br>
                        <br>// To call the getter method: 
                        <br>person.fullName; // 'John Doe'
                        <br>
                        <br>const objFactory = param => {
                        <br>&nbsp;return {
                        <br>&nbsp;&nbsp; _param: param,
                        <br>&nbsp;&nbsp;get param() {
                        <br>&nbsp;&nbsp;&nbsp;return this._param;
                        <br>&nbsp;&nbsp;},
                        <br>&nbsp;}
                        <br>}
                    </td>
                    <td>Getters (get)</td>
                    <td>Getters are methods that get and return the internal properties of an object. But they can do more than just retrieve the value of a property! Getters can perform an action on the data when getting a property. Getters can return different values using conditionals. When using getter (and setter) methods, keep in mind that <em>properties cannot share the same name as the getter/setter function</em>. If we do so, then calling the method will result in an infinite call stack error. One workaround is to add an underscore before the property name as in the example.
                        <br>
                        <br>
                        <ul>
                            <li>Use the <em>get</em> keyword followed by a <em>function</em>.</li>
                            <li>Use an <em>if...else</em> statement to check that data is available and true.</li>
                            <li>You can access the calling object’s internal properties using <em>this</em>.</li>
                            <li>In general, getter methods <em>do not need to be called with a set of parentheses</em>. Syntactically, it looks like we’re accessing a property.</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td class="vocab">const person = {
                        <br>&nbsp;_age: 37,
                        <br>&nbsp;set age(newAge){
                        <br>&nbsp;&nbsp;if (typeof newAge === 'number'){
                        <br>&nbsp;&nbsp;&nbsp;this._age = newAge;
                        <br>&nbsp;&nbsp;} else {
                        <br>&nbsp;&nbsp;&nbsp;console.log('You must assign a number to age');
                        <br>&nbsp;&nbsp;}
                        <br>&nbsp;}
                        <br>};
                        <br>
                        <br>person.age = 40;
                        <br>console.log(person._age); // Logs: 40
                        <br>
                        <br>person.age = '40'; // Logs: You must assign a number to age
                        <br>
                        <br>person._age = 'forty-five'
                        <br>console.log(person._age); // Prints forty-five
                    </td>
                    <td>Setters (set)</td>
                    <td>Reassign values of existing properties within an object. Again, the <em>typeof</em> operator validates data type. Setter methods like age do not need to be called with a set of parentheses. Syntactically, it looks like we’re reassigning the value of a property.</td>
                </tr>
                <tr>
                    <td class="vocab">const monsterFactory = (name, age, energySource, catchPhrase) => {
                        <br>&nbsp;return { 
                        <br>&nbsp;&nbsp;name: name,
                        <br>&nbsp;&nbsp;age: age, 
                        <br>&nbsp;&nbsp;energySource: energySource,
                        <br>&nbsp;&nbsp;scare() {
                        <br>&nbsp;&nbsp;&nbsp;console.log(catchPhrase);
                        <br>&nbsp;&nbsp;} 
                        <br>&nbsp;}
                        <br>};
                        <br>
                        <br>const ghost = monsterFactory('Ghouly', 251, 'ectoplasm', 'BOO!');
                        <br>ghost.scare(); // 'BOO!'
                    </td>
                    <td>Factory Functions</td>
                    <td>A real world factory manufactures multiple copies of an item quickly and on a massive scale. A factory function is a function that returns an object and can be reused to make multiple object instances. Factory functions can also have parameters allowing us to customize the object that gets returned.
                        <br>
                        <br>Now we have a ghost object as a result of calling monsterFactory() with the needed arguments. With monsterFactory in place, we don’t have to create an object literal every time we need a new monster. Instead, we can invoke the monsterFactory function with the necessary arguments.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">const monsterFactory = (name, age) => {
                        <br>&nbsp;return { 
                        <br>&nbsp;&nbsp;name,
                        <br>&nbsp;&nbsp;age 
                        <br>&nbsp;}
                        <br>};
                    </td>
                    <td>Property Value Shorthand</td>
                    <td>ES6 introduced some new shortcuts for assigning properties to variables known as <em>destructuring</em>. Notice that we don’t have to repeat ourselves for property assignments!</td>
                </tr>
                <tr>
                    <td class="vocab">const vampire = {
                        <br>&nbsp;name: 'Dracula',
                        <br>&nbsp;residence: 'Transylvania',
                        <br>&nbsp;preferences: {
                        <br>&nbsp;&nbsp;day: 'stay inside',
                        <br>&nbsp;&nbsp;night: 'satisfy appetite'
                        <br>&nbsp;}
                        <br>};
                        <br>
                        <br>const { residence } = vampire; 
                        <br>console.log(residence); // Prints 'Transylvania'
                    </td>
                    <td>Destructured Assignment</td>
                    <td>We often want to extract key-value pairs from objects and save them as variables. In <em>destructured assignment</em> we create a variable with the name of an object’s key that is wrapped in curly braces { } and assign to it the object. We can even use destructured assignment to grab nested properties of an object.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Built-in Object Methods</td>
                    <td>We have access to object instance methods like: .hasOwnProperty(), .valueOf(), and many more! Practice your documentation reading skills and check out: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#Methods" target="_blank">MDN’s object instance documentation</a>.</td>
                </tr>
            </tbody>
        </table>

        <!-- Methods -->
        <table>
            <thead>
                <tr>
                    <td colspan="3">Methods</td> 
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th scope="col" class="example">Example</th>
                    <th scope="col" class="name">Name</th>
                    <th scope="col" class="description">Description</th>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Methods</td>
                    <td>A method is a property with a function as its value. When the data stored on an object is a function we call that a <em>method</em>. A property is what an object has, while a method is what an object does.</td>
                </tr>
                <tr>
                    <td class="vocab">const resultString 
                        <br>= resultArray.join('').toUpperCase();</td>
                    <td>Chaining Methods</td>
                    <td>To perform multiple methods on a variable, simply connect them at the (dot) . The order matters.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Math.random()</td>
                    <td>Randomly generates a number between 0 and 1, but not including 0 or 1.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Math.floor()</td>
                    <td>Rounds the answer inside the parenthesis down to a whole number.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Math.ceil()</td>
                    <td>Rounds the answer inside the parenthesis up to a whole number.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Math.abs()</td>
                    <td>Expresses the absolute value of the answer inside the parenthesis.</td>
                </tr>
                <tr>
                    <td class="vocab">const sortYears = (array) => {
                        <br>&nbsp;return array.sort((a,b) => a &lt; b)
                        <br>};
                    </td>
                    <td>.sort()</td>
                    <td>Just putting .sort() on a variable will sort the array's elements in ascending order. The example sorts the elements in descending order, because a &lt; b. To list the array in ascending order, a &gt; b.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>.pageX</td>
                    <td>Returns horizontal coordinate of mouse pointer.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>.scrollLeft</td>
                    <td>Sets or returns the number of pixels an element's content is scrolled horizontally.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>.scrollWidth</td>
                    <td>Returns the width of the element's content including content not visible on screen due to overflow.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>.offsetWidth</td>
                    <td>Returns the viewable width of an element.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>.getBoundingClientRect()</td>
                    <td>Returns a DOMRect (describes size and position of rectangle) object providing information about the size of an element and its position relative to the viewport.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>.clientX</td>
                    <td>Property of the MouseEvent interface, provides the horizontal coordinate within the application's viewport at which the event occurred.</td>
                </tr>
            </tbody>
        </table>

        <!-- Scope -->
        <table>
            <thead>
                <tr>
                    <td colspan="3">Scope</td> 
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th scope="col" class="example">Example</th>
                    <th scope="col" class="name">Name</th>
                    <th scope="col" class="description">Description</th>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Scope</td>
                    <td>Scope defines where variables can be accessed or referenced. While some variables can be accessed from anywhere within a program, other variables may only be available in a specific context.</td>
                </tr>
                <tr>
                    <td class="vocab">const logSkyColor = () => 
                        <br><strong>{
                        <br>let color = 'blue'; 
                        <br>console.log(color); // blue 
                        <br>}</strong></td>
                    <td>Blocks</td>
                    <td>A block is the code found inside a set of curly braces {}. Blocks help us group one or more statements together and serve as an important structural marker for our code. A function body is an example of a block.</td>
                </tr>
                <tr>
                    <td class="vocab">const color = 'blue';
                        <br>
                        <br>const returnSkyColor = () => {
                        <br>return color; // blue 
                        <br>};
                        <br>
                        <br>console.log(returnSkyColor()); 
                        <br>// blue
                    </td>
                    <td>Global Scope</td>
                    <td>Scope is the context in which our variables are declared. We think about scope in relation to blocks because variables can exist either outside of or within these blocks. In <em>global scope</em>, variables are declared outside of blocks. These variables are called global variables. Because global variables are not bound inside a block, they can be accessed by any code in the program, including code in blocks.</td>
                </tr>
                <tr>
                    <td class="vocab">const logSkyColor = () => {
                        <br>let color = 'blue'; 
                        <br>console.log(color); 
                        <br>// Prints "blue"
                        <br>};
                        <br>
                        <br>logSkyColor(); // Prints "blue"
                        <br>console.log(color); 
                        <br>// throws a ReferenceError
                    </td>
                    <td>Block Scope</td>
                    <td>When a variable is defined inside a block, it is only accessible to the code within the curly braces {} (referred to as a <em>local variable</em>). We say that variable has block scope because it is only accessible to the lines of code within that block.</td>
                </tr>
                <tr>
                    <td class="vocab">let num = 50;
                        <br>
                        <br>const logNum = () => {
                        <br>num = 100; // Take note 
                        <br>console.log(num);
                        <br>};
                        <br>
                        <br>logNum(); // Prints 100
                        <br>console.log(num); // Prints 100
                    </td>
                    <td>Scope Pollution</td>
                    <td>Having too many global variables can cause problems in a program. When you declare global variables, they go to the global namespace. The global namespace allows the variables to be accessible from anywhere in the program. These variables remain there until the program finishes which means our global namespace can fill up really quickly. While it’s important to know what global scope is, <strong>it’s best practice to not define variables in the global scope.</strong></td>
                </tr>
            </tbody>
        </table>

        <!-- Arrays -->
        <table>
            <thead>
                <tr>
                    <td colspan="3">Arrays</td> 
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th scope="col" class="example">Example</th>
                    <th scope="col" class="name">Name</th>
                    <th scope="col" class="description">Description</th>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Arrays</td>
                    <td><em>Arrays</em> are JavaScript’s way of making lists. Arrays can store any data types (including strings, numbers, and booleans). Like lists, arrays are ordered, meaning each item has a numbered position. <a href="https://www.codecademy.com/resources/docs/javascript/arrays" target="_blank">Learn about Arrays</a>.</td>
                </tr>
                <tr>
                    <td class="vocab">let newYearsResolutions = ['Keep a journal', 'Take a falconry class', 'Learn to juggle'];</td>
                    <td>Array Literal</td>
                    <td>An <em>array literal</em> creates an array by wrapping items in square brackets []. In the example, the array is represented by the square brackets [] and the content inside. Each content item inside an array is called an <em>element</em>. In this example, the array is saved to a variable.</td>
                </tr>
                <tr>
                    <td class="vocab">let cities = ['New York', 'Beijing', 'Nairobi'];
                        <br>
                        <br>const hello = 'Hello World';
                        <br>console.log(hello[6]);
                        <br>// Output: W
                    </td>
                    <td>Accessing Elements</td>
                    <td>Each element in an array has a numbered position known as its <em>index</em>. We can access individual items using their index, which is similar to referencing an item in a list based on the item’s position. Arrays in JavaScript are <em>zero-indexed</em>, meaning the positions start counting from 0 rather than 1. Therefore, the first item in an array will be at position 0. In the example, <em>cities[0]</em> will access the element at index 0 in the array cities. You can think of cities[0] as accessing the space in memory that holds the string 'New York'.
                        <br>
                        <br>You can also access individual characters in a string using bracket notation and the index.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">let seasons = ['Winter', 'Spring', 'Summer', 'Fall'];
                        <br>seasons[3] = 'Autumn';
                        <br>console.log(seasons); 
                        <br>//Output: ['Winter', 'Spring', 'Summer', 'Autumn']
                    </td>
                    <td>Update Elements</td>
                    <td>Once you have access to an element in an array, you can update its value.</td>
                </tr>
                <tr>
                    <td class="vocab">const utensils = ['Fork', 'Knife', 'Chopsticks', 'Spork'];
                        <br>utensils[3] = 'Spoon';
                        <br>console.log(utensils);
                        <br>//Outputs: [ 'Fork', 'Knife', 'Chopsticks', 'Spoon' ]
                    </td>
                    <td>Arrays with let and const</td>
                    <td>Elements in an array declared with const (and let) remain mutable. Meaning that we can change the contents of a const array, but cannot reassign a new array or a different value.</td>
                </tr>
                <tr>
                    <td class="vocab">const newYearsResolutions = 
                        <br>['Keep a journal', 'Take a falconry class'];
                        <br>console.log(newYearsResolutions.length);
                        <br>// Output: 2
                    </td>
                    <td>.length</td>
                    <td>One of an array’s built-in properties is length and it returns the number of items in the array. We access the <em>.length</em> property just like we do with strings.</td>
                </tr>
                <tr>
                    <td class="vocab">const itemTracker = ['item 0', 'item 1', 'item 2'];
                        <br>
                        <br>itemTracker.push('item 3', 'item 4');
                        <br>
                        <br>console.log(itemTracker); 
                        <br>// Output: ['item 0', 'item 1', 'item 2', 'item 3', 'item 4'];
                    </td>
                    <td>.push()</td>
                    <td>Allows us to add items to the end of an array.</td>
                </tr>
                <tr>
                    <td class="vocab">const newItemTracker = 
                        <br>['item 0', 'item 1', 'item 2'];
                        <br>
                        <br>const removed = newItemTracker.pop();
                        <br>
                        <br>console.log(newItemTracker); 
                        <br>// Output: [ 'item 0', 'item 1' ]
                        <br>
                        <br>console.log(removed);
                        <br>// Output: item 2
                    </td>
                    <td>.pop()</td>
                    <td>Removes the last item of an array.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>More Array Methods</td>
                    <td>Some <a href="https://www.codecademy.com/resources/docs/javascript/arrays" target="_blank">arrays methods</a> that are available to JavaScript developers include: .join(), .slice(), .splice(), .shift(), .unshift(), and .concat() amongst many others. Some methods do not mutate the original array.</td>
                </tr>
                <tr>
                    <td class="vocab">const flowers = ['peony', 'daffodil', 'marigold'];
                        <br>
                        <br>function addFlower(arr) {
                        <br>arr.push('lily');
                        <br>}
                        <br>
                        <br>addFlower(flowers);
                        <br>
                        <br>console.log(flowers); 
                        <br>// Output: ['peony', 'daffodil', 'marigold', 'lily']
                    </td>
                    <td>Arrays & Functions</td>
                    <td>
                        <ul>
                            <li>The flowers array has 3 <em>elements</em>.</li>
                            <li>The <em>function</em> addFlower() has a <em>parameter</em> of arr, and uses .push() to add a 'lily' element into arr.</li>
                            <li>We call addFlower() with an <em>argument</em> of flowers which will execute the code inside addFlower.</li>
                            <li>We check the <em>value</em> of flowers and it now includes the 'lily' element! <em>The array was mutated!</em></li>
                        </ul>
                        <br>When you pass an array into a function, if the array is mutated inside the function, that change will be maintained outside the function as well. You might also see this concept explained as <em>pass-by-reference</em> since what we’re actually passing to the function is a reference to where the variable memory is stored and changing the memory.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">const nestedArr = [[1], [2, 3]];
                        <br>
                        <br>console.log(nestedArr[1]); 
                        <br>// Output: [2, 3]
                        <br>
                        <br>console.log(nestedArr[1][0]);
                        <br>// Output: 2
                    </td>
                    <td>Nested Arrays</td>
                    <td>Arrays can store other arrays. When an array contains another array it is known as a <em>nested array</em>. To access the nested arrays we can use bracket notation with the index value, just like we did to access any other element. Notice that nestedArr[1] will grab the element in index 1 which is the array [2, 3]. Then, if we wanted to access the elements within the nested array we can <em>chain</em>, or add on, more bracket notation with index values.</td>
                </tr>
            </tbody>
        </table>

        <!-- Loops -->
        <table>
            <thead>
                <tr>
                    <td colspan="3">Loops</td> 
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th scope="col" class="example">Example</th>
                    <th scope="col" class="name">Name</th>
                    <th scope="col" class="description">Description</th>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Loops</td>
                    <td>A <em>loop</em> is a programming tool that repeats a set of instructions until a specified condition, called a <em>stopping condition</em> is reached. As a programmer, you’ll find that you rely on loops all the time! You’ll hear the generic term <em>iterate</em> when referring to loops; iterate simply means “to repeat”. When we need to reuse a task in our code, we often bundle that action in a function. Similarly, when we see that a process has to repeat multiple times in a row, we write a loop. Loops allow us to create efficient code that automates processes to make scalable, manageable programs.</td>
                </tr>
                <tr>
                    <td class="vocab">for (let counter = 0; counter &lt; 4; counter++) {
                        <br>console.log(counter);
                        <br>}
                        <br>
                        <br>//Output
                        <br>0
                        <br>1
                        <br>2
                        <br>3
                    </td>
                    <td>for</td>
                    <td>The typical <em>for loop</em> includes an <em>iterator variable</em> that usually appears in all three expressions. The iterator variable is initialized, checked against the stopping condition, and assigned a new value on each loop iteration. Iterator variables can have any name, but it’s best practice to use a descriptive variable name.
                        <br>
                        <br>A <em>for</em> loop contains three expressions separated by ; inside the parentheses:
                        <br>
                        <br>
                        <ul>
                            <li>an <em>initialization</em> starts the loop and can also be used to declare the iterator variable.</li>
                            <li>a <em>stopping condition</em> is the condition that the iterator variable is evaluated against— if the condition evaluates to true the code block will run, and if it evaluates to false the code will stop.</li>
                            <li>an <em>iteration statement</em> is used to update the iterator variable on each loop.</li>
                        </ul>
                        <br>The code block is inside of the curly braces, console.log(counter), will execute until the condition evaluates to false. The condition will be false when counter is greater than or equal to 4 — the point that the condition becomes false is sometimes called the <em>stop condition</em>.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">for (let counter = 3; counter <strong>>=</strong> 0; counter--) {
                        <br>console.log(counter);
                        <br>};
                    </td>
                    <td>Looping in Reverse</td>
                    <td>To run a backward for loop, we must:
                        <br>
                        <br>
                        <ul>
                            <li>Set the <em>iterator variable</em> to the highest desired value in the initialization expression.</li>
                            <li>Set the <em>stopping condition</em> for when the iterator variable is less than the desired amount.</li>
                            <li>The iterator should <em>decrease</em> in intervals after each iteration.</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td class="vocab">const animals = ['Grizzly Bear', 'Sloth', 'Sea Lion'];
                        <br>
                        <br>for (let i = 0; i &lt; animals.length; i++){
                        <br>console.log(animals[i]);
                        <br>}
                        <br>
                        <br>//Output
                        <br>Grizzly Bear
                        <br>Sloth
                        <br>Sea Lion
                    </td>
                    <td>Looping through Arrays</td>
                    <td>We can use a for loop to perform the same operation on each element in an array. Arrays hold lists of data, like customer names or product information. Imagine we owned a store and wanted to increase the price of every product in our catalog. That could be a lot of repeating code, but by using a for loop to iterate through the array we could accomplish this task easily. <em>To loop through each element in an array, a for loop should use the array’s .length property in its condition.</em>
                        <br>
                        <br>In the loop above, we’ve named our iterator variable i. This is a variable naming convention you’ll see in a lot of loops. When we use i to iterate through arrays we can think of it as being short-hand for the word index. Notice how our stopping condition checks that i is less than animals.length. Remember that arrays are zero-indexed, the index of the last element of an array is equivalent to the length of that array minus 1. If we tried to access an element at the index of animals.length we will have gone too far!
                    </td>
                </tr>
                <tr>
                    <td class="vocab">const myArray = [6, 19, 20];
                        <br>const yourArray = [19, 81, 2];
                        <br>
                        <br>for (let i = 0; i &lt; myArray.length; i++) {
                        <br>&nbsp; for (let j = 0; j &lt; yourArray.length; j++) {
                        <br>&nbsp; &nbsp; if (myArray[i] === yourArray[j]) {
                        <br>&nbsp; &nbsp; &nbsp; console.log('Both arrays have the number: ' + yourArray[j]);
                        <br>&nbsp; &nbsp; }
                        <br>&nbsp; }
                        <br>}
                    </td>
                    <td>Nested Loops</td>
                    <td>When we have a loop running inside another loop, we call that a <em>nested loop</em>. One use for a nested <em>for</em> loop is to compare the elements in two arrays. For each round of the outer for loop, the inner for loop will run completely.
                        <br>
                        <br>Let’s think about what’s happening in the nested loop in our example. For each element in the outer loop array, myArray, the inner loop will run in its entirety comparing the current element from the outer array, myArray[i], to each element in the inner array, yourArray[j]. When it finds a match, it prints a string to the console.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">// A while loop that prints 1, 2, and 3
                        <br>
                        <br>let counterTwo = 1;
                        <br>
                        <br>while (counterTwo &lt; 4) {
                        <br>&nbsp;console.log(counterTwo);
                        <br>&nbsp;counterTwo++;
                        <br>}
                    </td>
                    <td>while</td>
                    <td>The syntax of a while loop is ideal when we don’t know in advance how many times the loop should run. 
                        <br>
                        <br>
                        <ul>
                            <li>The <em>counterTwo</em> variable is declared before the loop. We can access it inside our <em>while</em> loop since it’s in the global scope.</li>
                            <li>We start our loop with the keyword while followed by our stopping condition, or test condition. This will be evaluated before each round of the loop. While the condition evaluates to true, the block will continue to run. Once it evaluates to false the loop will stop.</li>
                            <li>Next, we have our loop’s code block which prints counterTwo to the console and increments counterTwo.</li>
                        </ul>
                    </td>
                </tr>
                <tr>
                    <td class="vocab">let countString = '';
                        <br>i = 0;
                        <br>
                        <br>do {
                        <br>countString = countString + i;
                        <br>i++;
                        <br>} while (i &lt; 5);
                        <br>
                        <br>console.log(countString);
                    </td>
                    <td>do...while</td>
                    <td>In some cases, you want a piece of code to run at least once and then loop based on a specific condition after its initial run. In this example, the code block makes changes to the countString variable by appending the string form of the i variable to it. First, the code block after the do keyword is executed once. Then the condition is evaluated. If the condition evaluates to true, the block will execute again. The looping stops when the condition evaluates to false.</td>
                </tr>
                <tr>
                    <td class="vocab">for (let i = 0; i &lt; 99; i++) {
                        <br>&nbsp;if (i > 2 ) {
                        <br>&nbsp;&nbsp;break;
                        <br>&nbsp;}
                        <br>&nbsp;console.log('Banana.');
                        <br>}
                        <br>
                        <br>console.log('Orange you glad I broke out the loop!');
                        <br>
                        <br>//Output:
                        <br>Banana.
                        <br>Banana.
                        <br>Banana.
                        <br>Orange you glad I broke out the loop!
                    </td>
                    <td>break</td>
                    <td> In our code, when we want to stop a loop from continuing to execute even though the original stopping condition we wrote for our loop hasn’t been met, we can use the keyword <em>break</em>. The break keyword allows programs to “break” out of the loop from within the loop’s block.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Infinite Loops</td>
                    <td>Avoid writing an <em>infinite loop</em>, or a loop without a stopping condition. This can take up all of your computer's computing power, potentially freezing your computer. If you do run into an infinite loop, refresh the page, and fix your code.</td>
                </tr>
                <tr>
                    <td class="vocab">const input = 'I love steak and milk';
                        <br>
                        <br>for (let i = 0; i &lt; input.length; i++) {
                        <br>
                        <br>};
                    </td>
                    <td>Iterating a String</td>
                    <td>Loops, or iterations, can be applied to each character (letter) in a string. Treat the string the same way that you would an array.</td>
                </tr>
                <tr>
                    <td class="vocab">const hobbies = ['singing', 'eating', 'quidditch', 'writing'];
                        <br>
                        <br>for (const hobby of hobbies) {
                        <br>console.log(`I enjoy ${hobby}.`);
                        <br>}                   
                    </td>
                    <td>for...of</td>
                    <td>A cleaner syntax for iterating through items, one by one.
                        <br>
                        <br>There is no need to set up additional variables to store an index with a for...of loop. The loop will iterate over each element in the iterable object and terminate itself when it reaches the last item — so you don’t need to track the number of items in the array. In our example, we used an array, but for...of loops also work with strings, sets, and other array-like objects.
                        <br>
                        <br>Therefore, you should opt for a standard for loop if you need to access the indices or need finer control to determine what elements you want to loop over. The for...of loop still allows you to use <em>break</em> and <em>continue</em>.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">const workoutAdvice = {
                        <br>&ensp;goal: ['lose bodyfat', 'build muscle', 'gain strength'],
                        <br>&ensp;start: ['going to bed early', 'eating real food', 'training hard'],
                        <br>&ensp;stop: ['staying up late', 'eating junk food', 'skipping the gym']
                        <br>};
                        <br>
                        <br>for (let advice in workoutAdvice) {
                        <br>let selector = generateRandomNumber(workoutAdvice[advice].length)
                        <br>
                        <br>switch (advice) {
                        <br>&ensp;case 'goal':
                    </td>
                    <td>for...in</td>
                    <td>Use this when iterating over an object's properties.</td>
                </tr>
                <tr>
                    <td class="vocab">const strangeBirds = ['Shoebill', 'Cockatrice', 'Basan', 'Cow', 'Terrorbird', 'Parotia', 'Kakapo'];
                        <br>
                        <br>for (const bird of strangeBirds) {
                        <br>&nbsp;if  (bird === 'Cow'){
                        <br>&nbsp;&nbsp;continue;
                        <br>&nbsp;}
                        <br>&nbsp;console.log(bird);
                        <br>}
                    </td>
                    <td>continue</td>
                    <td>The <em>continue</em> statement is used to skip one iteration of the loop.</td>
                </tr>
            </tbody>
        </table>

        <!-- Iterators -->
        <table>
            <thead>
                <tr>
                    <td colspan="3">Iterators</td> 
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th scope="col" class="example">Example</th>
                    <th scope="col" class="name">Name</th>
                    <th scope="col" class="description">Description</th>
                </tr>
                <tr>
                    <td class="vocab">const groceries = ['brown sugar', 'salt', 'cranberries', 'walnuts'];
                        <br>
                        <br>groceries.forEach(function(groceryItem) {
                        <br>&nbsp;console.log(' - ' + groceryItem);
                        <br>});
                        <br>
                        <br>const fruits = ['mango', 'papaya', 'pineapple', 'apple'];
                        <br>
                        <br>fruits.forEach(fruit => 
                        <br>&nbsp;console.log(`I want to eat a ${fruit}`));
                    </td>
                    <td>.forEach()</td>
                    <td>Executes the same code for each element of an array.
                        <br>
                        <br>In the example, <em>.forEach</em> is the iterator, and everything that follows it is the callback function.
                        <br>
                        <br><ul>
                                <li>groceries.forEach() calls the forEach method on the groceries array.</li>
                                <li><strong>As with all iterator functions, .forEach() takes an argument of a callback function.</strong> Remember, a callback function is a function passed as an argument into another function.</li>
                                <li>.forEach() loops through the array and executes the callback function for each element. During each execution, the current element is passed as an argument to the callback function.</li>
                                <li>The return value for .forEach() will always be undefined.</li>
                            </ul>
                    </td>
                </tr>
                <tr>
                    <td class="vocab">const numbers = [1, 2, 3, 4, 5]; 
                        <br>
                        <br>const bigNumbers = numbers.map(number => {
                        <br>&nbsp;return number * 10;
                        <br>});
                        <br>
                        <br>console.log(bigNumbers); // Output: [10, 20, 30, 40, 50]
                    </td>
                    <td>.map()</td>
                    <td>Takes an argument of a callback function and returns a new array.</td>
                </tr>
                <tr>
                    <td class="vocab">const words = ['chair', 'music', 'pillow', 'brick', 'pen', 'door']; 
                        <br>
                        <br>const shortWords = words.filter(word => {
                        <br>&nbsp;return word.length &lt; 6;
                        <br>});
                        <br>
                        <br>console.log(shortWords); // Output: ['chair', 'music', 'brick', 'pen', 'door']
                        <br>
                        <br>const justCoolStuff = (array1, array2) => array1.filter
                        <br>(element => array2.includes(element));
                    </td>
                    <td>.filter()</td>
                    <td>Returns a new array, after filtering out certain elements from the original array. The callback function for the .filter() method should return true or false depending on the element that is passed to it. The elements that cause the callback function to return true are added to the new array.
                        <br>
                        <br>The "justCoolStuff" example demonstrates how to check if 2 arrays contain the same elements using .filter().
                    </td>
                </tr>
                <tr>
                    <td class="vocab">const jumbledNums = [123, 25, 78, 5, 9]; 
                        <br>
                        <br>const lessThanTen = jumbledNums.findIndex(num => {
                        <br>&nbsp;return num &lt; 10;
                        <br>});
                        <br>
                        <br>console.log(lessThanTen); // Output: 3 
                        <br>console.log(jumbledNums[3]); // Output: 5
                    </td>
                    <td>.findIndex()</td>
                    <td>Returns the index of the first element that evaluates to true in the callback function. If there isn’t a single element in the array that satisfies the condition in the callback, then .findIndex() will return -1.</td>
                </tr>
                <tr>
                    <td class="vocab">const numbers = [1, 2, 4, 10];
                        <br>
                        <br>const summedNums = numbers.reduce((accumulator, currentValue) => {
                        <br>&nbsp;return accumulator + currentValue
                        <br>})
                        <br>
                        <br>console.log(summedNums) // Output: 17
                        <br>
                        <br>{return accumulator + currentValue}, 100)  // 100 is the second argument for .reduce(); Outputs 117
                    </td>
                    <td>.reduce()</td>
                    <td>Returns a single value after iterating through the elements of an array, thereby reducing the array. 
                        <br>
                        <br>In the example, accumulator begins with 1, and currentValue begins with 2. These numbers add together to make 3. Which, becomes the next accumulator, and 4 becomes the next currentValue. 3 + 4 = 7, and 7 + 10 = 17.
                        <br>
                        <br>The .reduce() method can also take an optional second parameter to set an initial value for accumulator (remember, the first argument is the callback function!).
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Iterator Documentation</td>
                    <td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array#Iteration_methods" target="_blank">Learn more here</a>.</td>
                </tr>
            </tbody>
        </table>

        <table>
            <thead>
                <tr>
                    <td colspan="3">Classes</td>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="vocab">class Dog {
                        <br>&emsp;constructor(name) {
                        <br>&emsp;&emsp;this._name = name;
                        <br>&emsp;&emsp;this._behavior = 0;
                        <br>&emsp;}
                        <br>}
                    </td>
                    <td>Class</td>
                    <td>Different from object identifiers.</td>
                </tr>
                <tr>
                    <td class="vocab">class Dog {
                        <br>&emsp;constructor(name) {
                        <br>&emsp;&emsp;this.name = name;
                        <br>&emsp;&emsp;this.behavior = 0;
                        <br>&emsp;}
                        <br>}
                    </td>
                    <td>constructor()</td>
                    <td>JavaScript calls the <strong>constructor()</strong> method every time it creates a new instance of a class. Capitalize and PascalCase class names. In the context of a class, <strong>this</strong> refers to an instance of that class. In the Dog class, we use <strong>this</strong> to set the value of the Dog instance’s name property to the name argument. Under this.name, we create a property called behavior, which will keep track of the number of times a dog misbehaves. The behavior property is always initialized to zero.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">const halley = <strong>new</strong> Dog('Halley');
                        <br>
                        <br>console.log(halley.name);
                    </td>
                    <td>Instances</td>
                    <td>An instance is an object that contains the property names and methods of a class, but with unique property values. Below our Dog class, we use the <strong>new</strong> keyword to create an instance of our Dog class.
                        <br>
                        <br><ul>
                                <li>We create a new variable named halley that will store an instance of our Dog class.</li>
                                <li>We use the <strong>new</strong> keyword to generate a new instance of the Dog class. The <strong>new</strong> keyword calls the constructor(), runs the code inside of it, and then returns the new instance.</li>
                                <li>We pass the 'Halley' string to the Dog constructor, which sets the name property to 'Halley'.</li>
                                <li>Finally, we log the value saved to the name key in our halley object, which logs 'Halley' to the console.</li>
                            </ul>
                    </td>
                </tr>
                <tr>
                    <td class="vocab">class Surgeon {
                    <br>&emsp;constructor... {}
                    <br>
                    <br>&emsp;get name() {
                    <br>&emsp;&emsp;return this._name;
                    <br>&emsp;}
                    <br>
                    <br>&emsp;takeVacationDays(daysOff) {
                    <br>&emsp;&emsp;this._remainingVacationDays = this._remainingVacationDays - daysOff;
                    <br>&emsp;}
                    <br>}
                    </td>
                    <td>Methods</td>
                    <td>Class method and getter syntax is the same as it is for objects except <strong>you can not include commas between methods</strong>.</td>
                </tr>
                <tr>
                    <td class="vocab">surgeonRomero.name</td>
                    <td>Method Calls</td>
                    <td>The syntax for calling methods and getters on an instance is the same as calling them on an object — append the instance with a period, then the property or method name. For methods, you must also include opening and closing parentheses.</td>
                </tr>
                <tr>
                    <td class="vocab">class Animal {}...
                        <br>
                        <br>class Cat <strong>extends</strong> Animal {
                        <br>&emsp;constructor(name, usesLitter) {
                        <br>&emsp;&emsp;<strong>super</strong>(name);
                        <br>&emsp;&emsp;this._usesLitter = usesLitter;
                        <br>&emsp;}
                        <br>}
                    </td>
                    <td>Inheritance</td>
                    <td>With inheritance, you can create a parent class (also known as a superclass) with properties and methods that multiple child classes (also known as subclasses) share. The child classes inherit the properties and methods from their parent class.
                        <br>
                        <br><ul>
                                <li>The <strong>extends</strong> keyword makes the methods of the animal class available inside the cat class.</li>
                                <li>The constructor, called when you create a new Cat object, accepts two arguments, name and usesLitter.</li>
                                <li>The <strong>super</strong> keyword calls the constructor of the parent class. In this case, super(name) passes the name argument of the Cat class to the constructor of the Animal class. When the Animal constructor runs, it sets this._name = name; for new Cat instances.</li>
                                <li>_usesLitter is a new property that is unique to the Cat class, so we set it in the Cat constructor.</li>
                            </ul>
                        <br>
                        <br><em>In a constructor(), you must always call the <strong>super</strong> method before you can use the <strong>this</strong> keyword — if you do not, JavaScript will throw a reference error.</em>
                    </td>
                </tr>
                <tr>
                    <td class="vocab">class....
                        <br>&emsp;constructor...
                        <br>
                        <br>&emsp;static generateName() {}
                    </td>
                    <td>static Methods</td>
                    <td>Sometimes you will want a class to have methods that aren’t available in individual instances, but that you can call directly from the class. Because of the <strong>static</strong> keyword, we can only access .generateName() by appending it to the name of the class.</td>
                </tr>
            </tbody>
        </table>

        <table>
            <thead>
                <tr>
                    <td colspan="3">Modules</td>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="vocab"></td>
                    <td>Modules</td>
                    <td>Modules are reusable pieces of code in a file that can be exported and then imported for use in another file (module and file are often used interchangably). Modules are used for <strong>Separation of Concerns:</strong> separate a program so that each module handles a particular task (e.g. multiple .js files).
                        <br>
                        <br><ul>
                                <li>find, fix, and debug code more easily</li>
                                <li>reuse and recycle defined logic in different parts of your application</li>
                                <li>keep information private and protected from other modules</li>
                                <li>prevent pollution of the global namespace and potential naming collisions, by cautiously selecting variables and behavior we load into a program</li>
                            </ul>
                        <br>Example: 2 websites that use the exact same code, word for word, line by line. Creating a single copy of the code within a module that exports it would allow these two websites to import and use the exact same function. With this approach, updates to the function only need to occur within the module that defines them, and all programs that import this function will receive the same update. Furthermore, additional functions could be exported by the module and used by both programs, further reducing repetition.
                    </td>
                </tr><tr>
                    <td class="vocab"></td>
                    <td>Modular Program</td>
                    <td>A modular program is one whose components can be separated, used individually, and recombined to create a complex system.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Module File Structure</td>
                    <td>A module must be entirely contained within a file. The module's file should be in the same parent folder as the programs that use it. </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Implementations of Modules in JavaScript</td>
                    <td>In JavaScript, there are two runtime environments and each has a preferred module implementation:
                        <br>
                        <br><ul>
                                <li>The Node runtime environment and the module.exports and require() syntax. <a href="https://www.codecademy.com/courses/learn-intermediate-javascript/articles/implementing-modules-in-node">Read More</a></li>
                                <li>The browser’s runtime environment and the ES6 import/export syntax.</li>
                            </ul>
                    </td>
                </tr>
                <tr>
                    <td class="vocab">export <br>{ resourceToExportA, resourceToExportB, ... }
                        <br>
                        <br>export const toggleHiddenElement = (domElement) => {}
                    </td>
                    <td>ES6 Named Export Syntax (browser)</td>
                    <td>Using this syntax, the name of each exported resource (e.g. function) is listed between curly braces and separated by commas. This line of code is written at the end of the js file.
                        <br>
                        <br>In addition to the syntax above, in which all named exports are listed together, individual values may be exported as named exports by simply placing the export keyword in front of the variable’s declaration.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">import { exportedResourceA, exportedResourceB } from '/path/to/module.js';
                        <br>
                        <br>&lt;script type="module" src="./secret-messages.js"&gt;&lt;/script&gt;
                    </td>
                    <td>ES6 Named Import Syntax (browser)</td>
                    <td>This line of code is written at the beginning of the js file (before the variables and functions that require the imported code). In the path, starting with ./ indicates that the modules file is in the same parent folder as the current js file.
                        <br>
                        <br>You must also modify your html file, by adding the attribute <strong>type='module'</strong> to the &lt;script&gt; element. Failure to do so can cause some browsers to throw an error.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">import { exportedResource as newlyNamedResource } from '/path/to/module'</td>
                    <td>Renaming Imports to Avoid Naming Collisions</td>
                    <td>ES6 includes syntax for renaming imported resources by adding in the keyword <strong>as</strong>.</td>
                </tr>
                <tr>
                    <td class="vocab">const resources = { 
                        <br>&emsp;valueA, 
                        <br>&emsp;valueB 
                        <br>}
                        <br>export { resources as default };
                        <br>
                        <br>//Or
                        <br>
                        <br>export default resources;
                    </td>
                    <td>Default Exports</td>
                    <td>Every module also has the option to export a single value to represent the entire module called the default export. Often, though not always, the default export value is an object containing the entire set of functions and/or data values of a module. With this syntax, the object containing the module’s resources is first declared and then is exported on the next line. At first glance, it looks like the resources object is being exported as a named export. However, the clause as default renames the exported object to default, a reserved identifier that can only be given to a single exported value.</td>
                </tr>
                <tr>
                    <td class="vocab">import { default as importedResources } from 'module.js
                        <br>
                        <br>import importedResources from 'module.js';</td>
                    <td>Default Imports</td>
                    <td>The imported default value may be given any name the programmer chooses. It should be noted that if the default export is an object, the values inside cannot be extracted until after the object is imported.</td>
                </tr>
            </tbody>
        </table>

        <!-- Testing -->
        <table>
            <thead>
                <tr>
                    <td colspan="3">Testing</td>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="vocab"></td>
                    <td>Why Test?</td>
                    <td><strong>In 2002</strong>, a study commissioned by the US Department of Commerce’s National Institute of Standards and Technology concluded that <strong>software errors cost the US economy about $59 billion annually</strong>. To avoid those costs, software professionals use automated testing. During and after production, they can run an <em>automated test suite</em> to give themselves confidence that their products are free of errors and work as expected.
                        <br>
                        <br><strong>The process for testing is as follows: write code changes, make pull request, run test(s), fix code, repeat until test passes, merge the pull request.</strong>
                        <br>
                        <br><a href="https://www.codecademy.com/article/tdd-u1-good-test" target="_blank">The characteristics of a good test:</a> fast, complete, reliable, isolated, maintainable, and expressive.
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Manual Testing</td>
                    <td>Software testing is the process of assessing the completeness and quality of computer software. Usually this is done by running a part of a system (like a web application) and comparing the actual behavior to the expected behavior. <strong>Manual testing is a form of testing done by a human interacting with a system. With web apps, this might be clicking, dragging, and typing through a webpage</strong>. A list of actions and expected behaviors would be given. If the observed behavior doesn’t match the expected behavior, the application has an error.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Automated Testing</td>
                    <td>The cost of testing can be reduced and the quality can be improved with automated testing. <strong>Automated testing is the use of software to control the execution of tests and the comparison of actual behavior to expected behavior.</strong> Automated testing is faster, more accurate, and more maintainable.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>The Test Suite</td>
                    <td>Tests are written with code, just like the rest of your web app. You can refer to the code defining your app as <em>implementation code</em>, and the code defining your tests as <em>test code</em>. If implementation code is written in index.js then the corresponding test code may be written in index-test.js. <strong>A collection of tests for a web application is called a test suite.</strong></td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Tests As Documentation</td>
                    <td><strong>Documentation is any content separate from implementation code that explains how it works or how to use it.</strong> Documentation can come in many forms, including plain text, diagrams…and tests! Tests as documentation provide what many other forms cannot: both human-readable text to describe the application and machine-executable code to confirm the app works as described.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Regression</td>
                    <td><strong>When adding a new feature to your product, it’s possible that something will break. If that break occurs within a feature developed earlier, it is called regression</strong>.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Testing Types</td>
                    <td>At different stages of production for a particular project, you may encounter the opportunity for different types of tests, which can vary in scale and resource intensity, as well as serve different purposes.
                        <br>
                        <br><ul>
                                <li><strong>Unit Tests:</strong> covers the smallest possible unit of testable code, such as a single function. In order to keep the scope of a unit test focused on the unit being tested, any data or behavior from other units or external sources that the unit relies on should be replaced with fake (mock) data or behavior.</li>
                                <li><strong>Integration Tests:</strong> covers how the units of a particular program work with one another. When testing integrations with external services, only the handling of incoming data is tested while the data itself remains mocked.</li>
                                <li><strong>End to End Tests:</strong> (sometimes referred to as a UI layer test or e2e) automates user flow to test the application in the way that a real user would experience it. To closely match the end user’s experience, this type of testing would also test interactions with external services such as databases and APIs. In this test, the actual database and external API is used.</li>
                            </ul>
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Testing Methodologies</td>
                    <td>Some software testing methodologies prioritize writing test cases before writing the code those test cases will validate. Those types include:
                        <br>
                        <br><ul>
                                <li><strong>Test-driven Development (TDD):</strong> a methodology that flips the order, where tests are written before the functioning code is written. TDD tests look at the components of code, like functions and classes, as the smallest unit to test. In practice, TDD can accelerate software development since it dictates short development cycles with direct test cases.</li>
                                <li><strong>Behavior-driven Development (BDD):</strong> also involves writing test before code. BDD differs from TDD in why or when tests are written, what an individual unit is considered to be, and how the language of the test is composed (BDD is more specific). Since BDD tests are driven by behavior, the language of the test cases are simplified and written via collaboration between engineers, product owners, and other stakeholders, to ensure the specified behaviors make sense from a user perspective. Changes to the code base, such as changing the design of the code, will not occur unless there is a relevant change in the product. Since those changes are feature-related, the unit of tests is called a “feature.” Test cases are related to whether or not the feature works, rather than if the individual functions or classes you are writing to develop features work.</li>
                                <li><strong>Specification by Example (SBE):</strong></li>
                                <li><strong>Acceptance Test-driven Development (ATDD):</strong></li>
                            </ul>
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Installing Mocha</td>
                    <td>Developers use <strong>test frameworks</strong> to organize and automate tests that provide useful feedback when errors occur.
                        <br>
                        <br><ul>
                                <li><strong>Node</strong> allows you to run JavaScript in the terminal</li>
                                <li><strong>npm</strong> is a Node tool that allows you to download packages from the web, and manage them in a JavaScript project</li>
                                <li><strong>Mocha</strong> is one of those packages and is used to test other JavaScript code</li>
                            </ul>
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>npm init</td>
                    <td>In Git Bash, this command creates a file <strong>package.json</strong> that can be used to manage packages for the project. After running this command you will be prompted to enter information about your project. It’s okay to skip some fields if you’re not ready to enter that information.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>$ npm install mocha -D</td>
                    <td>With your project setup, you can install packages. Here’s what this command means:
                        <br>
                        <br><ul>
                                <li>npm install tells npm to install a package from the internet and any other packages it depends on</li>
                                <li>mocha is the package you want to download</li>
                                <li>-D signifies that this package is a development dependency and will show up under the devDependecies section in package.json. This means that the package will only be included in development mode and will not be included in the production bundle.</li>
                            </ul>
                        <br>Once you npm install packages, you can find the packages and all their dependencies in the node_modules folder. The new directory structure contains the following:
                        <br>
                        <br>project
                        <br>|_ node_modules
                        <br>|___ .bin
                        <br>|___ mocha
                        <br>|___ ...
                        <br>|_ package.json
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Running Mocha</td>
                    <td>The first (and more tedious) method is to <strong>call it directly from node_modules</strong>:
                        <br>
                        <br><strong>$ ./node_modules/mocha/bin/mocha</strong>
                        <br>
                        <br>The second (and recommended) method is to <strong>add a script to package.json.</strong> In the scripts object in package.json, set the value of "test" to mocha. It should look like this:
                        <br>
                        <br><strong>"scripts": {
                        <br>&emsp;"test": "mocha"
                        <br>}</strong>
                        <br>
                        <br>Now you can call Mocha with the following command: <strong>$ npm test</strong>. Instead of manually running each test in the test directory, you can use this command to run the full test suite automatically.
                    </td>
                </tr>
                <tr>
                    <td class="vocab"><img src="./Images/describe and it functions.png" alt="image of describe and it block code example" class="example-img"></td>
                    <td>describe and it blocks</td>
                    <td>In Mocha we <strong>group tests using the describe function</strong> and <strong>define tests using the it function</strong>. These two functions can be used to make your test suite complete, maintainable, and expressive in the following ways:
                        <br>
                        <br><ul>
                                <li>Structure your test suite: you can organize tests into nested groups that reflect the structure of your implementation code.</li>
                                <li>Provide informative messages: you can define your tests using human-readable strings.</li>
                            </ul>
                        <br>Both the <strong>describe</strong> and <strong>it</strong> functions <strong>accept two parameters: a descriptive string and a callback function</strong>. Though the functions are flexible, they are commonly used in the structure above: nest describe blocks to resemble the structure of your implementation code and write individual tests in it blocks.
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Testing Phases</td>
                    <td>The phases of a test are defined as follows:
                        <br>
                        <br><ul>
                                <li><strong>Setup:</strong> create objects, variables, and set conditions that your test depends on</li>
                                <li><strong>Execute:</strong> execute the functionality you are testing</li>
                                <li><strong>Verify:</strong> check your expectations against the result of the exercise phase. You can use the assert library here</li>
                                <li><strong>Teardown:</strong> adding a teardown step to the end of a test resets the environment before the next test runs. This prevents changes to the environment from one test affecting the environment for the next test.</li>
                            </ul>
                        <br>While execution and verification are unique to each test, setup and teardown are often similar or even identical for multiple tests within a test suite.
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Teardown</td>
                    <td>In most situations, we will need to write many tests for a particular feature that get executed in succession. Running multiple tests can introduce issues if the tests make changes to the testing environment: changes to the environment in one test might affect the next test. Some common changes to an environment include:
                        <br>
                        <br><ul>
                                <li>altering files and directory structure</li>
                                <li>changing read and write permissions on a file</li>
                                <li>editing records in a database</li>
                            </ul>
                        <br>To address this issue, we often add a <strong>teardown</strong> step to the end of our tests (e.g. the it function). The teardown phase makes our tests isolated by resetting the environment before the next test runs.
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>fs.appendFileSync(path, str)</td>
                    <td>In the Git Bash terminal, this creates a new file at path with the string str as content. If a file at path exists, the string str will be appended to the end.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>fs.readFileSync(path)</td>
                    <td>Returns the contents of the file found at path.</td>
                </tr>
                <tr>
                    <td class="vocab">describe...
                        <br>
                        <br>let testValue;
                        <br>
                        <br>beforeEach(() => {
                        <br>&emsp;testValue = 5;
                        <br>});
                        <br>
                        <br>it...
                    </td>
                    <td>Hooks</td>
                    <td>The Mocha test framework provides functions that enable us to reduce repetition, simplify the scope of each test, and more finely control the execution of our tests.
                        <br>
                        <br><ul>
                                <li><strong>beforeEach(callback)</strong> callback is run before each test</li>
                                <li><strong>afterEach(callback)</strong> callback is run after each test</li>
                                <li><strong>before(callback)</strong> callback is run before the first test (useful for separating out the setup steps of your tests)</li>
                                <li><strong>after(callback)</strong> callback is run after the last test (useful for separating out the teardown steps of your tests.)</li>
                            </ul>
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Expressive Testing</td>
                    <td>An expressive test is easy to read and descriptive. One way to make a test more expressive is clarifying its verify phase — the step where expected outcome is compared to actual outcome. Node.js provides a library called <strong>assert</strong> with methods that help you write more expressive verification code. You can use the methods in this library in place of conditional statements to write less code and use human-readable language. It can be used within the Mocha testing framework.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>const assert = require('assert');</td>
                    <td>As a Node module, this function can import assert at the top of your JS files.</td>
                </tr>
                <tr>
                    <td class="vocab"><img src="./Images/assert.png" alt="" class="example-img-tall">
                    </td>
                    <td>assert.ok()</td>
                    <td>To write the tests themselves (specifically the verify phase), we can use the <strong>assert.ok()</strong> method provided by Node.js. <strong>assert.ok()</strong> allows you to compare values and throw errors as needed using one function call.
                        <br>
                        <br>You call assert functions in an <strong>it block</strong> like this: <strong>assert.ok(a === 3);</strong> If an argument passed to assert.ok() evaluates to false, an <em>AssertionError</em> is thrown. The error communicates to Mocha that a test has failed, and Mocha logs the error message to the console. 
                        <br>
                        <br>In the example, it is common practice to <strong>pass result first and expected second</strong>.
                        <br>
                        <br><a href="https://nodejs.org/api/assert.html" target="_blank">Functions in the assert library</a>
                        <br>
                        <br><a href=https://www.chaijs.com/guide/ target="_blank">chai.js assertion library</a>
                    </td>
                </tr>
                <tr>
                    <td class="vocab">assert.ok(5 == '5');
                        <br>
                        <br>assert.equal(5, '5'); //OK
                    </td>
                    <td>assert.equal()</td>
                    <td>Performs a == (loose equality) comparison. The examples each produce the same result. The second line is more expressive: instead of parsing the entire statement, a reader only needs to read the first two words to know the test is verifying equality!</td>
                </tr>
                <tr>
                    <td class="vocab">assert.strictEqual(5, 5); //OK</td>
                    <td>assert.strictEqual()</td>
                    <td>Performs a === (strict equality) comparison. July 2021 Update: <strong>the assert documentation recommends always using assert.strictEqual() instead of assert.equal()</strong>.</td>
                </tr>
                <tr>
                    <td class="vocab">const a = {number: 5};
                        <br>const b = {number: 5};
                        <br>
                        <br>assert.deepEqual(a,b); //OK
                    </td>
                    <td>assert.deepEqual()</td>
                    <td>Performs a == (loose equality) <strong>comparison of the values</strong> within two objects. Arrays are also objects, so deepEqual() also compares their values with loose equality. Different objects with identicle properties are not considered equal when using either loose or strict equality in JavaScript.</td>
                </tr>
                <tr>
                    <td class="vocab">assert.notStrictEqual(1, 2); //OK
                        <br>
                        <br>assert.notStrictEqual(1, '1'); //OK
                    </td>
                    <td>assert.notStrictEqual()</td>
                    <td>Performs a !=== (strict inequality) comparison.</td>
                </tr>
                <tr>
                    <td class="vocab">assert.throws(() => {}, expected);</td>
                    <td>assert.throws()</td>
                    <td>Indicates whether a function returns a specific error (expected). The first parameter is an anonymous function, and the second parameter is the expected error.</td>
                </tr>
                <tr>
                    <td class="vocab">Write test code that fails
                        <br>
                        <br>Write implementation code so the test passes
                        <br>
                        <br>Consider refactoring the code
                    </td>
                    <td>The Red-Green-Refactor Cycle</td>
                    <td>One of the driving forces of TDD is the red-green-refactor cycle. “Red” and “green” correspond to the color of the text that our test framework produces in the terminal while running the tests in our suite. Red signifies failing tests and green corresponds to passing tests.
                        <br>
                        <br><ul>
                                <li><strong>Red:</strong> write tests that describe the intended behavior of implementation code <strong>(describe and it block)</strong>, and then compare developer expectations with the actual results of implementation code <strong>(assert statement)</strong>. The tests should always fail at first because the implementation code for the desired behavior will be written in response to the failing test.</li>
                                <li><strong>Green:</strong> write <strong>just enough implementation code to make the test pass</strong>. The tests return green because the implementation code executes the intended behavior described by the test in the red phase.</li>
                                <li><strong>Refactor:</strong> clean up and optimize code following the characteristics of a good test <strong>(add setup, execute, verify, teardown)</strong>. Refactoring involves actively considering test and implementation code and making revisions to the code base. The tests are passing and should continue to pass throughout this phase of the cycle.</li>
                            </ul>
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Edge Case</td>
                    <td>An edge case is a problem or situation that occurs only at an extreme (maximum or minimum) operating parameter — you can think of these as special cases that you need to account for (number instead of string).</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Code Coverage</td>
                    <td>The metric that <strong>measures the percentage of how many lines of code have been tested</strong>. For example, if 90% of our code has been executed in our tests, then we would say that we have “90% code coverage”. Some key criteria to use when measuring code coverage include:
                        <br>
                        <br><ul>
                                <li><strong>Function Coverage:</strong> Has each function been called?</li>
                                <li><strong>Statement Coverage:</strong> Has each statement been executed? (e.g. return)</li>
                                <li><strong>Path Coverage:</strong> Has every edge in the control-flow graph been executed? (e.g. if, else)</li>
                                <li><strong>Condition Coverage:</strong> Has each boolean sub-expression evaluated to be both true and false?</li>
                            </ul>
                        <br>Having 100% code coverage does not guarantee bug-free code – it simply validates the completeness of our tests using a given set of criteria relative to other test suites with lower code coverage.
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Test Coverage</td>
                    <td>Test coverage differs from code coverage in that test coverage <strong>measures the percentage of the required features/specs that are tested</strong>, as opposed to the percentage of lines executed. These features/specs are typically defined in a requirements document provided by a client or product designer.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Mocking in Tests</td>
                    <td>Mocking is the process of <strong>creating a fake version of an external service for testing purposes</strong>, particularly in unit tests and integration tests. Mocking is effective in testing individual units of code without relying on the functionality of other services or units such as APIs or databases. By removing dependencies, we are limiting the sources of potential bugs and unintended results to just the feature being tested. This is also known as <strong>stubbing</strong>. While it’s helpful to use mocks in unit tests, we should avoid using mocks in integration tests to better simulate interactions between internal services (though external services should remain mocked).</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Sinon.js</td>
                    <td><strong>A JavaScript library that includes standalone fakes, spies, and mocks that can be used in any unit testing framework.</strong> <a href="https://sinonjs.org/releases/latest/spies/" target="_blank">Sinon.js spies documentation</a></td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Spy</td>
                    <td><strong>A function that observes and records information about another function’s calls</strong> including arguments, return value, the <strong>this</strong> value, and exceptions thrown (if any). The information that is observed by the spy can then be used in assertions for testing.</td>
                </tr>
                <tr>
                    <td class="vocab"><img src="./Images/sinon.spy.png" alt="image of sinon.spy code example" class="example-img-tall"></td>
                    <td>How to Spy</td>
                    <td>Many ways including anonymous functions and wrapping around a method. The <strong>sinon.spy()</strong> method is used to wrap the method in the example. To ensure that the method returns to its original, un-spied-on state, we use the <strong>.restore()</strong> method.</td>
                </tr>
            </tbody>
        </table>

        <!-- Error Handling -->
        <table>
            <thead>
                <tr>
                    <td colspan="3">Error Handling</td>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="vocab"></td>
                    <td>Error Handling</td>
                    <td>Error handling is the process of programmatically anticipating and addressing errors.</td>
                </tr>
                <tr>
                    <td class="vocab">console.log(Error('Your password is too weak.'));
                        <br>// Prints: Error: Your password is too weak.
                        <br>
                        <br>console.log(new Error('Your password is too weak.'));
                    </td>
                    <td>Error Function</td>
                    <td>Let’s say we need to inform a user that a string passed in as an argument is too short with a custom message. Such a message isn’t covered by a built-in error, but we could use the Error function to make our own error object with a message that is unique to our program!
                        <br>
                        <br>The Error function takes an argument of a string which becomes the value of the error’s message property. You might also see errors created with the new keyword.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">throw Error('Something wrong happened');
                        <br>// Error: Something wrong happened
                    </td>
                    <td>throw</td>
                    <td>Creating an error doesn’t cause our program to stop — remember, an error must be thrown for it to halt the program.
                        <br>
                        <br>To throw an error in JavaScript, we use the <strong>throw</strong> keyword. When we use the throw keyword, the error is thrown and code after the throw statement will not execute.
                    </td>
                </tr>
                <tr>
                    <td class="vocab">try {
                        <br>&emsp;throw Error('This error will get caught');
                        <br>} catch (e) {
                        <br>&emsp;console.log(e);
                        <br>}
                        <br>// Prints: This error will get caught</td>
                    <td>try...catch</td>
                    <td>In JavaScript, we use try...catch statements to anticipate and handle errors. <strong>These statements allow our program to keep running despite the error.</strong>
                        <br>
                        <br><ul>
                                <li>We have code that follows try inside curly braces {} known as the try block.</li>
                                <li>Inside the try block we insert code that we anticipate might throw an error.</li>
                                <li>Since we want to see what happens if an error is thrown in the try block, we throw an error with the message 'This error will get caught'.</li>
                                <li>Following the try block is the catch statement which accepts the thrown error from the try block . <strong>The e represents the thrown error</strong>.</li>
                                <li>The curly braces that follow catch(e) is known as the catch block and contains code that executes to handle the error.</li>
                            </ul>
                    </td>
                </tr>
                <tr>
                    <td class="vocab">const someVar = 'Cannot be reassigned';
                        <br>try {
                        <br>&emsp;someVar = 'Still going to try';
                        <br>} catch(e) {
                        <br>&emsp;console.log(e);
                        <br>}
                        <br>
                        <br>// Prints: TypeError: Assignment to constant variable.</td>
                    <td>Handling with try...catch</td>
                    <td>We can also use a try...catch statement <strong>to handle built-in errors</strong> that are thrown by the JavaScript engine that is reading and evaluating our code. Using a try...catch statement for built-in JavaScript errors is really beneficial when we need to use data from an external source that’s not written directly in our program. Let’s say we expect to grab an array from a database but the information we get back is a string. In our program, we could have a function that only works on arrays. If that function was called with a string instead of an array we would get an error and our program would stop running!</td>
                </tr>
            </tbody>
        </table>

        <!-- Debugging JavaScript -->
        <table>
            <thead>
                <tr>
                    <td colspan="3">Debugging JavaScript</td> 
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th scope="col" class="example">Example</th>
                    <th scope="col" class="name">Name</th>
                    <th scope="col" class="description">Description</th>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>List of Errors</td>
                    <td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors" target="_blank">List of errors</a></td>
                </tr>
                <tr>
                    <td class="vocab"><img class="example-img" src="C:/Software/Projects/0_Ethan's Code Cheat Sheet/Ethan's Code Cheat Sheet/Images/Screenshot 2023-11-19 215136.png" alt="Img Unavailable"></td>
                    <td>Error Stack Traces</td>
                    <td>Errors: big red text. A piece of software, called a <em>compiler</em>, is trying to translate your code so that your computer can understand and run it. However, the compiler is coming across a piece of code that it can’t interpret. As a result, it throws an error back to you to let you know that it has to stop and why. This information is logged as an <strong>error stack trace</strong> — a printed message containing information about where the error occurred, what type of error was thrown, and a description of the error.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Runtime Errors</td>
                    <td>When we execute code and a line of code throws an error, that error is referred to as a runtime error. In JavaScript, there are built-in error objects that have a name and message property which tell us what went wrong (see below).</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>JavaScript Error Types</td>
                    <td>
                            <strong>SyntaxError:</strong> This error will be thrown when a typo creates invalid code — code that cannot be interpreted by the compiler. When this error is thrown, scan your code to make sure you properly opened and closed all brackets, braces, and parentheses and that you didn’t include any invalid semicolons.
                        <br>
                        <br><strong>ReferenceError:</strong> This error will be thrown if you try to use a variable that does not exist. When this error is thrown, make sure all variables are properly declared (check scope).
                        <br>
                        <br><strong>TypeError:</strong> This error will be thrown if you attempt to perform an operation on a value of the wrong type. For example, if we tried to use a string method on a number, it would throw a TypeError.
                        <br>
                        <br><strong>EvalError:</strong> This error will be thrown regarding the global function <em>eval()</em>.
                        <br>
                        <br><strong>RangeError:</strong> This error will be thrown when a numeric variable or parameter is outside its valid range.
                        <br>
                        <br><strong>URIError:</strong> This error will be thrown when <em>encodeURI()</em> or <em>decodeURI()</em> are passed invalid parameters.
                        <br>
                        <br><strong>AggregateError:</strong> This error will be thrown representing several errors wrapped in a single error when multiple errors need to be reported by an operation.
                        <br>
                        <br><strong>InternalError:</strong> This error will be thrown when there's an internal error in the JavaScript engine.
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Debugging Errors</td>
                    <td>
                        <ol>
                            <li>Run your code. Using the first error’s stack trace, identify the error’s type, description, and location.</li>
                            <li>Go to the file name and line number indicated by the error stack trace. Using the error type and description, identify the bug in your code.</li>
                            <li>Fix the bug and re-run your code.</li>
                            <li>Repeat steps 1-3 until your code no longer throws any errors.</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td class="vocab">console.log()</td>
                    <td>Locating Silent Bugs</td>
                    <td>Even if your code runs error-free, it is not necessarily bug-free. You may find that your code is consistently returning incorrect values without throwing any errors. A lack of thrown errors does not mean your code logic is completely correct. An incredibly powerful tool for locating bugs is a method you likely learned very early on in your JavaScript journey: console.log()! By adding print statements to our code, we can identify where things have gone wrong.</td>
                </tr>
                <tr>
                    <td class="vocab">console.log()</td>
                    <td>Debugging with console.log()</td>
                    <td>
                        <ol>
                            <li>Go to the beginning of the malfunctioning code. Print out all starting variables, existing values, and arguments using console.log(). If the values are what you expect, move on to the next piece of logic in the code. If not, you have identified a bug and should skip to step 3.</li>
                            <li>After the next piece of logic in your code, add console.log() statements to ensure updated variables have the values that you now expect and that the block of code is being executed. If that logic is executing properly, continue repeating this step until you find a line not working as expected, then move to step 3.</li>
                            <li>Fix the identified bug and run your code again. If it now works as expected, you’ve finished debugging! If not, continue stepping through your code using step 2 until it does.</li>
                        </ol>
                    </td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Documentation</td>
                    <td><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript" target="_blank">MDN JavaScript web docs</a>. We encourage you to explore the docs, but often the fastest way to access a specific part of the docs you’re interested in is to Google it. For example, if we wanted more information on the Number object’s .isNan() method, we could Google “MDN isNan” and then click the link to the MDN page. If we were looking to see a list of all of the String built-in methods, we might Google “MDN String”, click the link to MDN, and then scroll down to the “Methods” section of the documentation.</td>
                </tr>
                <tr>
                    <td class="vocab"></td>
                    <td>Stack Overflow</td>
                    <td><a href="https://stackoverflow.com/" target="_blank">Stack Overflow</a></td>
                </tr>
            </tbody>
        </table>

    </body>

</html>